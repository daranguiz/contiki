./apps/webserver-nano/httpd-cgi.c:short sleepcount;
./apps/webserver-nano/httpd-cgi.c://  extern unsigned long seconds, sleepseconds;
./apps/webserver-nano/httpd-cgi.c:  numprinted = httpd_snprintf(buf, sizeof(buf),httpd_cgi_ajax10,tmp,bat,iter,tmp,bat,sleepcount,OCR2A,0,clock_time(),clock_seconds());
./apps/webserver-nano/httpd-cgi.c:  numprinted = httpd_snprintf(buf, sizeof(buf),httpd_cgi_ajax10,tmp,bat,iter,tmp,bat,sleepcount,OCR2A,0,clock_time(),clock_seconds());
./apps/webserver-nano/httpd-cgi.c: * Low power mode l is essentially zero for cpus that sleep.
./output.txt:./apps/webserver-nano/httpd-cgi.c:short sleepcount;
./output.txt:./apps/webserver-nano/httpd-cgi.c://  extern unsigned long seconds, sleepseconds;
./output.txt:./apps/webserver-nano/httpd-cgi.c:  numprinted = httpd_snprintf(buf, sizeof(buf),httpd_cgi_ajax10,tmp,bat,iter,tmp,bat,sleepcount,OCR2A,0,clock_time(),clock_seconds());
./output.txt:./apps/webserver-nano/httpd-cgi.c:  numprinted = httpd_snprintf(buf, sizeof(buf),httpd_cgi_ajax10,tmp,bat,iter,tmp,bat,sleepcount,OCR2A,0,clock_time(),clock_seconds());
./output.txt:./apps/webserver-nano/httpd-cgi.c: * Low power mode l is essentially zero for cpus that sleep.
./output.txt:./cpu/cc2430/rtimer-arch.c: *         clock and etimer are using the sleep timer on the cc2430
./output.txt:./cpu/cc2430/dev/dma.h:#define DMA_T_ST        11 /* Sleep Timer compare */
./output.txt:./cpu/cc2430/dev/clock.c:/* Sleep timer runs on the 32k RC osc. */
./output.txt:./cpu/cc2430/dev/clock.c:volatile __bit sleep_flag;
./output.txt:./cpu/cc2430/dev/clock.c:/* Used in sleep timer interrupt for calculating the next interrupt time */
./output.txt:./cpu/cc2430/dev/clock.c:  IEN0_STIE = 1; /* IEN0.STIE acknowledge Sleep Timer Interrupt */
./output.txt:./cpu/cc2430/dev/clock.c:   * If the Sleep timer throws an interrupt while we are powering down to
./output.txt:./cpu/cc2430/dev/clock.c:   * PM1, we need to abort the power down. Clear SLEEP.MODE, this will signal
./output.txt:./cpu/cc2430/dev/clock.c:  SLEEP &= 0xFC;
./output.txt:./cpu/cc2430/dev/clock.c:  sleep_flag = 1;
./output.txt:./cpu/cc2430/dev/cc2430_rf.c:  SLEEP &= ~OSC_PD; /*Osc on*/
./output.txt:./cpu/cc2430/dev/cc2430_rf.c:  while((SLEEP & XOSC_STB) == 0); /*wait for power up*/
./output.txt:./cpu/cc2430/cc2430_sfr.h:__sfr __at (0xBE)   SLEEP;
./output.txt:./cpu/cc2430/cc2430_sfr.h:#define SLEEP_MODE1	0x02
./output.txt:./cpu/cc2430/cc2430_sfr.h:#define SLEEP_MODE0	0x01
./output.txt:./cpu/avr/rtimer-arch.c:#if RDC_CONF_MCU_SLEEP
./output.txt:./cpu/avr/rtimer-arch.c:rtimer_arch_sleep(rtimer_clock_t howlong)
./output.txt:./cpu/avr/rtimer-arch.c:/* Deep Sleep for howlong rtimer ticks. This will stop all timers except
./output.txt:./cpu/avr/rtimer-arch.c: * precision but smaller maximum sleep time.
./output.txt:./cpu/avr/rtimer-arch.c: * Here a maximum 128msec (contikimac 8Hz channel check sleep) is assumed.
./output.txt:./cpu/avr/rtimer-arch.c: * The rtimer and system clocks are adjusted to reflect the sleep time.
./output.txt:./cpu/avr/rtimer-arch.c:#include <avr/sleep.h>
./output.txt:./cpu/avr/rtimer-arch.c:	set_sleep_mode(SLEEP_MODE_PWR_SAVE);
./output.txt:./cpu/avr/rtimer-arch.c:#if 0    //Prescale by 1024 -   32 ticks/sec, 8 seconds max sleep
./output.txt:./cpu/avr/rtimer-arch.c:#elif 0  // Prescale by 256 -  128 ticks/sec, 2 seconds max sleep
./output.txt:./cpu/avr/rtimer-arch.c:#elif 0  // Prescale by 128 -  256 ticks/sec, 1 seconds max sleep
./output.txt:./cpu/avr/rtimer-arch.c:#elif 0  // Prescale by  64 -  512 ticks/sec, 500 msec max sleep
./output.txt:./cpu/avr/rtimer-arch.c:#elif 1  // Prescale by  32 - 1024 ticks/sec, 250 msec max sleep
./output.txt:./cpu/avr/rtimer-arch.c:#elif 0  // Prescale by   8 - 4096 ticks/sec, 62.5 msec max sleep
./output.txt:./cpu/avr/rtimer-arch.c:#else    // No Prescale -    32768 ticks/sec, 7.8 msec max sleep
./output.txt:./cpu/avr/rtimer-arch.c:/* Enable TIMER2 output compare interrupt, sleep mode and sleep */
./output.txt:./cpu/avr/rtimer-arch.c:	if (OCR2A) sleep_mode();
./output.txt:./cpu/avr/rtimer-arch.c:/* Disable sleep mode after wakeup, so random code cant trigger sleep */
./output.txt:./cpu/avr/rtimer-arch.c:/* Adjust clock.c for the time spent sleeping */
./output.txt:./cpu/avr/rtimer-arch.c:#endif /* RDC_CONF_MCU_SLEEP */
./output.txt:./cpu/avr/watchdog.c: * It should be disabled during sleep (unless used for wakeup) since
./output.txt:./cpu/avr/rtimer-arch.h:void rtimer_arch_sleep(rtimer_clock_t howlong);
./output.txt:./cpu/avr/dev/clock-avr.h:  while the 1284p is sleeping. The Jackdaw has pads for a crystal. The crystal
./output.txt:./cpu/avr/dev/clock-avr.h:  The 1284p routine also uses TIMER2 to sleep a variable number of seconds.
./output.txt:./cpu/avr/dev/lanc111.c:     * becomes zero. We sleep 63 ms before each poll and
./output.txt:./cpu/avr/dev/lanc111.c:        NutSleep(63);
./output.txt:./cpu/avr/dev/lanc111.c:    NutSleep(63);
./output.txt:./cpu/avr/dev/lanc111.c:    NutSleep(63);
./output.txt:./cpu/avr/dev/lanc111.c:            NutSleep(63);
./output.txt:./cpu/avr/dev/lanc111.c:        NutSleep(63);
./output.txt:./cpu/avr/dev/lanc111.c:      /*NutSleep(1000);*/
./output.txt:./cpu/avr/dev/lanc111.c:    //NutSleep(500);
./output.txt:./cpu/avr/dev/lanc111.c:    //NutSleep(500);
./output.txt:./cpu/avr/dev/rtlregs.h:#define NIC_CONFIG3_SLEEP   0x04 /*!< \brief Sleep mode */
./output.txt:./cpu/avr/dev/rs232.h: *             The return value of the input handler affects the sleep
./output.txt:./cpu/avr/dev/rs232.h: *             is kept sleeping.
./output.txt:./cpu/avr/dev/rtl8019.c:     * Disable sleep and power down.
./output.txt:./cpu/avr/dev/rtl8019.c:    /*    NutSleep(WAIT500);*/
./output.txt:./cpu/avr/dev/rtl8019.c:    /*    NutSleep(WAIT500);*/
./output.txt:./cpu/avr/dev/clock.c:/* sleepseconds is the number of seconds sleeping since startup, available globally */
./output.txt:./cpu/avr/dev/clock.c:long sleepseconds;
./output.txt:./cpu/avr/dev/clock.c: * Typically used to add ticks after an MCU sleep
./output.txt:./cpu/avr/dev/clock.c:    sleepseconds++;
./output.txt:./cpu/avr/dev/usb/usb_task.c:#include <avr/sleep.h>
./output.txt:./cpu/avr/dev/usb/usb_task.c: *   \brief Spare function to handle sleep mode.
./output.txt:./cpu/avr/dev/usb/usb_task.c:   set_sleep_mode(SLEEP_MODE_PWR_DOWN);
./output.txt:./cpu/avr/dev/usb/usb_task.c:   sleep_mode();
./output.txt:./cpu/avr/radio/rf230/radio.c:    TIME_SLEEP_TO_TRX_OFF            = 880, /**<  Transition time from SLEEP to TRX_OFF. */
./output.txt:./cpu/avr/radio/rf230/radio.c:bool radio_is_sleeping(void);
./output.txt:./cpu/avr/radio/rf230/radio.c: *                          be changed (SLEEP).
./output.txt:./cpu/avr/radio/rf230/radio.c:    if (radio_is_sleeping() == true){
./output.txt:./cpu/avr/radio/rf230/radio.c: *                          device is sleeping.
./output.txt:./cpu/avr/radio/rf230/radio.c:    if (radio_is_sleeping() == true){
./output.txt:./cpu/avr/radio/rf230/radio.c: *  \retval RADIO_WRONG_STATE This function cannot be called in the SLEEP state.
./output.txt:./cpu/avr/radio/rf230/radio.c:    /* Ensure that the radio transceiver is not sleeping. */
./output.txt:./cpu/avr/radio/rf230/radio.c:    if (radio_is_sleeping() == true){
./output.txt:./cpu/avr/radio/rf230/radio.c: *  \note This function can not be called from P_ON or SLEEP. This is ensured
./output.txt:./cpu/avr/radio/rf230/radio.c: *  \note This function can not be called from P_ON or SLEEP. This is ensured
./output.txt:./cpu/avr/radio/rf230/radio.c: *  \retval RADIO_WRONG_STATE The device is sleeping.
./output.txt:./cpu/avr/radio/rf230/radio.c:    if (radio_is_sleeping() == true){
./output.txt:./cpu/avr/radio/rf230/radio.c: *  \note This function can not be called from P_ON or SLEEP. This is ensured
./output.txt:./cpu/avr/radio/rf230/radio.c: *                  has been taken to SLEEP and awaken again.
./output.txt:./cpu/avr/radio/rf230/radio.c:        /*Select to change the CLKM frequency directly or after returning from SLEEP.*/
./output.txt:./cpu/avr/radio/rf230/radio.c: *                                 that the controller could be sleeping.
./output.txt:./cpu/avr/radio/rf230/radio.c: *                                 could be sleeping since the CLKM pin is
./output.txt:./cpu/avr/radio/rf230/radio.c:/** \brief  This function checks if the radio transceiver is sleeping.
./output.txt:./cpu/avr/radio/rf230/radio.c: *  \retval     true    The radio transceiver is in SLEEP or one of the *_NOCLK
./output.txt:./cpu/avr/radio/rf230/radio.c: *  \retval     false   The radio transceiver is not sleeping.
./output.txt:./cpu/avr/radio/rf230/radio.c:bool radio_is_sleeping(void)
./output.txt:./cpu/avr/radio/rf230/radio.c:    bool sleeping = false;
./output.txt:./cpu/avr/radio/rf230/radio.c:    /* The radio transceiver will be at SLEEP or one of the *_NOCLK states only if */
./output.txt:./cpu/avr/radio/rf230/radio.c:        sleeping = true;
./output.txt:./cpu/avr/radio/rf230/radio.c:    return sleeping;
./output.txt:./cpu/avr/radio/rf230/radio.c:    if (radio_is_sleeping() == true){
./output.txt:./cpu/avr/radio/rf230/radio.c:/** \brief  This function will put the radio transceiver to sleep.
./output.txt:./cpu/avr/radio/rf230/radio.c: *  \retval    RADIO_SUCCESS          Sleep mode entered successfully.
./output.txt:./cpu/avr/radio/rf230/radio.c:radio_enter_sleep_mode(void)
./output.txt:./cpu/avr/radio/rf230/radio.c:    if (radio_is_sleeping() == true){
./output.txt:./cpu/avr/radio/rf230/radio.c:    radio_status_t enter_sleep_status = RADIO_TIMED_OUT;
./output.txt:./cpu/avr/radio/rf230/radio.c:        /* Enter Sleep. */
./output.txt:./cpu/avr/radio/rf230/radio.c:        enter_sleep_status = RADIO_SUCCESS;
./output.txt:./cpu/avr/radio/rf230/radio.c:    return enter_sleep_status;
./output.txt:./cpu/avr/radio/rf230/radio.c:/** \brief  This function will take the radio transceiver from sleep mode and
./output.txt:./cpu/avr/radio/rf230/radio.c: *  \retval    RADIO_SUCCESS          Left sleep mode and entered TRX_OFF state.
./output.txt:./cpu/avr/radio/rf230/radio.c:radio_leave_sleep_mode(void)
./output.txt:./cpu/avr/radio/rf230/radio.c:    /* Check if the radio transceiver is actually sleeping. */
./output.txt:./cpu/avr/radio/rf230/radio.c:    if (radio_is_sleeping() == false){
./output.txt:./cpu/avr/radio/rf230/radio.c:    delay_us(TIME_SLEEP_TO_TRX_OFF);
./output.txt:./cpu/avr/radio/rf230/radio.c:    radio_status_t leave_sleep_status = RADIO_TIMED_OUT;
./output.txt:./cpu/avr/radio/rf230/radio.c:        leave_sleep_status = RADIO_SUCCESS;
./output.txt:./cpu/avr/radio/rf230/radio.c:    return leave_sleep_status;
./output.txt:./cpu/avr/radio/rf230/radio.c: *          its states, except for the SLEEP state.
./output.txt:./cpu/avr/radio/rf230/radio.c: *                          SLEEP state.
./output.txt:./cpu/avr/radio/rf230/radio.c:    if (radio_is_sleeping() == true){
./output.txt:./cpu/avr/radio/rf230/radio.h:radio_status_t radio_enter_sleep_mode( void );
./output.txt:./cpu/avr/radio/rf230/radio.h:radio_status_t radio_leave_sleep_mode( void );
./output.txt:./cpu/avr/radio/rf230/at86rf230_registermap.h:/** Constant SLEEP for sub-register @ref SR_TRX_STATUS */
./output.txt:./cpu/avr/radio/rf230/at86rf230_registermap.h:#define SLEEP                    (15)
./output.txt:./cpu/avr/radio/ieee-manager/ieee-15-4-manager.h:    int (* sleep)(void);
./output.txt:./cpu/avr/radio/ieee-manager/ieee-15-4-manager.c:  return radio_leave_sleep_mode();
./output.txt:./cpu/avr/radio/ieee-manager/ieee-15-4-manager.c:sleep(void)
./output.txt:./cpu/avr/radio/ieee-manager/ieee-15-4-manager.c:  /* Sleep the radio. */
./output.txt:./cpu/avr/radio/ieee-manager/ieee-15-4-manager.c:  return radio_enter_sleep_mode();
./output.txt:./cpu/avr/radio/ieee-manager/ieee-15-4-manager.c:  pieee_15_4_manager->sleep = sleep;
./output.txt:./cpu/avr/radio/rf230bb/halbb.c:    /*IO Specific Initialization - sleep and reset pins. */
./output.txt:./cpu/avr/radio/rf230bb/halbb.c:    /*IO Specific Initialization - sleep and reset pins. */
./output.txt:./cpu/avr/radio/rf230bb/rf230bb.c:#define RADIOSLEEPSWHENOFF 1
./output.txt:./cpu/avr/radio/rf230bb/rf230bb.c:    TIME_SLEEP_TO_TRX_OFF            = 880, /**<  Transition time from SLEEP to TRX_OFF. */
./output.txt:./cpu/avr/radio/rf230bb/rf230bb.c: *                                 that the controller could be sleeping.
./output.txt:./cpu/avr/radio/rf230bb/rf230bb.c: *                                 could be sleeping since the CLKM pin is
./output.txt:./cpu/avr/radio/rf230bb/rf230bb.c:/** \brief  This function checks if the radio transceiver is sleeping.
./output.txt:./cpu/avr/radio/rf230bb/rf230bb.c: *  \retval     true    The radio transceiver is in SLEEP or one of the *_NOCLK
./output.txt:./cpu/avr/radio/rf230bb/rf230bb.c: *  \retval     false   The radio transceiver is not sleeping.
./output.txt:./cpu/avr/radio/rf230bb/rf230bb.c:static bool radio_is_sleeping(void)
./output.txt:./cpu/avr/radio/rf230bb/rf230bb.c:    bool sleeping = false;
./output.txt:./cpu/avr/radio/rf230bb/rf230bb.c:    /* The radio transceiver will be at SLEEP or one of the *_NOCLK states only if */
./output.txt:./cpu/avr/radio/rf230bb/rf230bb.c:        sleeping = true;
./output.txt:./cpu/avr/radio/rf230bb/rf230bb.c:    return sleeping;
./output.txt:./cpu/avr/radio/rf230bb/rf230bb.c: *          its states, except for the SLEEP state.
./output.txt:./cpu/avr/radio/rf230bb/rf230bb.c:    delay_us(2*TIME_SLEEP_TO_TRX_OFF);
./output.txt:./cpu/avr/radio/rf230bb/rf230bb.c://  delay_us(TIME_SLEEP_TO_TRX_OFF+TIME_SLEEP_TO_TRX_OFF/2);
./output.txt:./cpu/avr/radio/rf230bb/rf230bb.c:#if RADIOSLEEPSWHENOFF
./output.txt:./cpu/avr/radio/rf230bb/rf230bb.c:  /* Sleep Radio */
./output.txt:./cpu/avr/radio/rf230bb/rf230bb.c:    PRINTF("rf230_set_txpower:Sleeping");  //happens with cxmac
./output.txt:./cpu/avr/radio/rf230bb/rf230bb.c:   * (JTAG, WDT, Brownout) the radio may be sleeping. It can enter an uncertain
./output.txt:./cpu/avr/radio/rf230bb/rf230bb.c:  delay_us(2*TIME_SLEEP_TO_TRX_OFF);
./output.txt:./cpu/avr/radio/rf230bb/rf230bb.c:  /* If radio is sleeping we have to turn it on first */
./output.txt:./cpu/avr/radio/rf230bb/rf230bb.c:    delay_us(2*TIME_SLEEP_TO_TRX_OFF); //extra delay depends on board capacitance
./output.txt:./cpu/avr/radio/rf230bb/rf230bb.c://	delay_us(TIME_SLEEP_TO_TRX_OFF+TIME_SLEEP_TO_TRX_OFF/2);
./output.txt:./cpu/avr/radio/rf230bb/rf230bb.c:		PRINTF("rf230_get_txpower:Sleeping");
./output.txt:./cpu/avr/radio/rf230bb/rf230bb.c:    if (hal_get_slptr()) {  //should not be sleeping!
./output.txt:./cpu/avr/radio/rf230bb/atmega128rfa1_registermap.h:/** Constant SLEEP for sub-register @ref SR_TRX_STATUS */
./output.txt:./cpu/avr/radio/rf230bb/atmega128rfa1_registermap.h:#define SLEEP                    (15)
./output.txt:./cpu/avr/radio/rf230bb/at86rf230_registermap.h:/** Constant SLEEP for sub-register @ref SR_TRX_STATUS */
./output.txt:./cpu/avr/radio/rf230bb/at86rf230_registermap.h:#define SLEEP                    (15)
./output.txt:./cpu/avr/radio/mac/sicslowmac.c: * end nodes to sleep.
./output.txt:./cpu/avr/radio/mac/sicslowmac.c: * end nodes to sleep.
./output.txt:./cpu/avr/radio/mac/sicslowmac.c:mac_sleep(void)
./output.txt:./cpu/mc1322x/contiki-crm.c:void sleep(uint32_t opts, uint32_t mode)
./output.txt:./cpu/mc1322x/contiki-crm.c:	/* the maca must be off before going to sleep */
./output.txt:./cpu/mc1322x/contiki-crm.c:	*CRM_SLEEP_CNTL = opts;
./output.txt:./cpu/mc1322x/contiki-crm.c:	*CRM_SLEEP_CNTL = (opts | mode);
./output.txt:./cpu/mc1322x/contiki-crm.c:	/* wait for the sleep cycle to complete */
./output.txt:./cpu/mc1322x/contiki-crm.c:        /* write 1 to sleep_sync --- this clears the bit (it's a r1wc bit) and powers down */
./output.txt:./cpu/mc1322x/contiki-crm.c:	/* now we are asleep */
./output.txt:./cpu/mc1322x/contiki-crm.c:        /* write 1 to sleep_sync --- this clears the bit (it's a r1wc bit) and finishes the wakeup */
./output.txt:./cpu/mc1322x/tests/Makefile:           sleep \
./output.txt:./cpu/mc1322x/tests/config.h:/* sleep */
./output.txt:./cpu/mc1322x/tests/sleep.c:	putstr("sleep test\n\r");
./output.txt:./cpu/mc1322x/tests/sleep.c:	/* radio must be OFF before sleeping */
./output.txt:./cpu/mc1322x/tests/sleep.c:	/* go to sleep */
./output.txt:./cpu/mc1322x/tests/sleep.c://	*CRM_SLEEP_CNTL = 1; /* hibernate, RAM page 0 only, don't retain state, don't power GPIO */ /* approx. 2kHz = 2.0uA */
./output.txt:./cpu/mc1322x/tests/sleep.c://	*CRM_SLEEP_CNTL = 0x41; /* hibernate, RAM page 0 only, retain state, don't power GPIO */ /* approx. 2kHz = 10.0uA */
./output.txt:./cpu/mc1322x/tests/sleep.c://	*CRM_SLEEP_CNTL = 0x51; /* hibernate, RAM page 0&1 only, retain state, don't power GPIO */ /* approx. 2kHz = 11.7uA */
./output.txt:./cpu/mc1322x/tests/sleep.c://	*CRM_SLEEP_CNTL = 0x61; /* hibernate, RAM page 0,1,2 only, retain state, don't power GPIO */ /* approx. 2kHz = 13.9uA */
./output.txt:./cpu/mc1322x/tests/sleep.c:	*CRM_SLEEP_CNTL = 0x71; /* hibernate, all RAM pages, retain state, don't power GPIO */ /* approx. 2kHz = 16.1uA */
./output.txt:./cpu/mc1322x/tests/sleep.c://	*CRM_SLEEP_CNTL = 0xf1; /* hibernate, all RAM pages, retain state,       power GPIO */ /* consumption depends on GPIO hookup */
./output.txt:./cpu/mc1322x/tests/sleep.c://	*CRM_SLEEP_CNTL = 2; /* doze     , RAM page 0 only, don't retain state, don't power GPIO */ /* approx. 69.2 uA */
./output.txt:./cpu/mc1322x/tests/sleep.c://	*CRM_SLEEP_CNTL = 0x42; /* doze     , RAM page 0 only, retain state, don't power GPIO */ /* approx. 77.3uA */
./output.txt:./cpu/mc1322x/tests/sleep.c://	*CRM_SLEEP_CNTL = 0x52; /* doze     , RAM page 0&1 only, retain state, don't power GPIO */ /* approx. 78.9uA */
./output.txt:./cpu/mc1322x/tests/sleep.c://	*CRM_SLEEP_CNTL = 0x62; /* doze     , RAM page 0,1,2 only, retain state, don't power GPIO */ /* approx. 81.2uA */
./output.txt:./cpu/mc1322x/tests/sleep.c://	*CRM_SLEEP_CNTL = 0x72; /* doze     , all RAM pages, retain state, don't power GPIO */ /* approx. 83.4uA - possibly with periodic refresh*/
./output.txt:./cpu/mc1322x/tests/sleep.c://	*CRM_SLEEP_CNTL = 0xf2; /* doze     , all RAM pages, retain state,       power GPIO */ /* consumption depends on GPIO hookup */
./output.txt:./cpu/mc1322x/tests/sleep.c:	/* wait for the sleep cycle to complete */
./output.txt:./cpu/mc1322x/tests/sleep.c:	/* write 1 to sleep_sync --- this clears the bit (it's a r1wc bit) and powers down */
./output.txt:./cpu/mc1322x/tests/sleep.c:	/* asleep */
./output.txt:./cpu/mc1322x/tests/sleep.c:	/* write 1 to sleep_sync --- this clears the bit (it's a r1wc bit) and finishes wakeup */
./output.txt:./cpu/mc1322x/README.subtree:For instance, if you need a routine called sleep, but libmc1322x
./output.txt:./cpu/mc1322x/README.subtree:doesn't have that yet, you could implement sleep in
./output.txt:./cpu/mc1322x/doc/ws-dis:    3e00:	455f4753 	ldrbmi	r4, [pc, #-1875]	; 36b5 <CRM_GoToSleep+0x69>
./output.txt:./cpu/mc1322x/doc/ws-dis:    3668:	347fad0a 	ldrbtcc	sl, [pc], #3338	; 3670 <CRM_GoToSleep+0x24>
./output.txt:./cpu/mc1322x/tools/rftestrx2pcap.pl:use Time::HiRes qw(usleep gettimeofday);
./output.txt:./cpu/mc1322x/tools/mc1322x-load.pl:use Time::HiRes qw(usleep);
./output.txt:./cpu/mc1322x/tools/mc1322x-load.pl:    print "       -a first  intercharacter delay, passed to usleep\n";
./output.txt:./cpu/mc1322x/tools/mc1322x-load.pl:    print "       -b second intercharacter delay, passed to usleep\n";
./output.txt:./cpu/mc1322x/tools/mc1322x-load.pl:                usleep($first_delay)  if ( $s == 0 ) && ($first_delay != 0);
./output.txt:./cpu/mc1322x/tools/mc1322x-load.pl:                usleep($second_delay) if ( $s == 1 ) && ($second_delay != 0);
./output.txt:./cpu/mc1322x/tools/ftditools/bbmc.c:	sleep(2);
./output.txt:./cpu/mc1322x/lib/include/crm.h:		uint32_t SLEEP_CNTL;
./output.txt:./cpu/mc1322x/lib/include/crm.h:		struct CRM_SLEEP_CNTL {
./output.txt:./cpu/mc1322x/lib/include/crm.h:		} SLEEP_CNTLbits;
./output.txt:./cpu/mc1322x/lib/include/crm.h:			uint32_t SLEEP_SYNC:1;
./output.txt:./cpu/mc1322x/lib/include/crm.h:static volatile uint32_t * const CRM_SLEEP_CNTL = ((volatile uint32_t *) (CRM_BASE+0x08));
./output.txt:./cpu/mc1322x/lib/include/crm.h:#define SLEEP_MODE_HIBERNATE bit(0)
./output.txt:./cpu/mc1322x/lib/include/crm.h:#define SLEEP_MODE_DOZE      bit(1)
./output.txt:./cpu/mc1322x/lib/include/crm.h:#define SLEEP_PAD_PWR     bit(7)
./output.txt:./cpu/mc1322x/lib/include/crm.h:#define SLEEP_RETAIN_MCU bit(6)
./output.txt:./cpu/mc1322x/lib/include/crm.h:#define sleep_ram_retain(x) (x<<4)   /* 0-3 */
./output.txt:./cpu/mc1322x/lib/include/crm.h:#define SLEEP_RAM_8K sleep_ram_retain(0)
./output.txt:./cpu/mc1322x/lib/include/crm.h:#define SLEEP_RAM_32K sleep_ram_retain(1)
./output.txt:./cpu/mc1322x/lib/include/crm.h:#define SLEEP_RAM_64K sleep_ram_retain(2)
./output.txt:./cpu/mc1322x/lib/include/crm.h:#define SLEEP_RAM_96K sleep_ram_retain(3)
./output.txt:./cpu/mc1322x/clock.c: * Adjust clock ticks after a cpu sleep.
./output.txt:./cpu/msp430/f5xxx/msp430.c:   sleep modes where the DCO clock stopped */
./output.txt:./cpu/msp430/dev/lpm.h:#define LPM_SLEEP() do { if(lpm_status == LPM_STATUS_ON) LPM_ON; } while(0)
./output.txt:./cpu/msp430/f1xxx/msp430.c:   sleep modes where the DCO clock stopped */
./output.txt:./cpu/stm32w108/Makefile.stm32w108:		stm32w-radio.c stm32w_systick.c uip_arch.c rtimer-arch.c adc.c micro.c sleep.c \
./output.txt:./cpu/stm32w108/hal/error-def.h: * @brief Sleeping (for a duration) has been abnormally interrupted
./output.txt:./cpu/stm32w108/hal/error-def.h:#define ST_SLEEP_INTERRUPTED(0x85)
./output.txt:./cpu/stm32w108/hal/error-def.h:DEFINE_ERROR(SLEEP_INTERRUPTED, 0x85)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c: * \b NOTE:  The Sleep Timer count and compare registers are only 16 bits, but
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c: * the "action" register.  When working with SLEEPTMR_CNT, reading the "H"
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c: * be read.  When working with the SLEEPTMR_CMP registers, writing "L" will
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c://A simple flag used by internalSleepForQs to check that it has exited
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c://from sleep mode at the request of the expected timer interrupt.
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:static boolean sleepTimerInterruptOccurred = FALSE;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:  time = SLEEPTMR_CNTH<<16;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:  time |= SLEEPTMR_CNTL;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:void halSleepTimerIsr(void)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:  INT_SLEEPTMRFLAG = INT_SLEEPTMRWRAP | INT_SLEEPTMRCMPA | INT_SLEEPTMRCMPB;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:  //mark a sleep timer interrupt as having occurred
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:  sleepTimerInterruptOccurred = TRUE;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:static StStatus internalSleepForQs(boolean useGpioWakeMask,
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:  int32u sleepOverflowCount;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:    INT_CFGCLR = INT_SLEEPTMR;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:    //overflow of 4194304.0 seconds.  Calculate the number of sleep overflows
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:    sleepOverflowCount = (*duration)/TIMER_MAX_QS;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:    //grab the starting sleep count
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:    sleepTimerInterruptOccurred = FALSE;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      SLEEPTMR_CMPAL = (startCount+remainder)&0xFFFF;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      SLEEPTMR_CMPAH = ((startCount+remainder)>>16)&0xFFFF;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      INT_SLEEPTMRFLAG = INT_SLEEPTMRCMPA;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      INT_SLEEPTMRCFG = INT_SLEEPTMRCMPA;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:    if(sleepOverflowCount) {
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      SLEEPTMR_CMPBL = startCount&0xFFFF;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      SLEEPTMR_CMPBH = (startCount>>16)&0xFFFF;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      INT_SLEEPTMRFLAG = INT_SLEEPTMRCMPB;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      INT_SLEEPTMRCFG = INT_SLEEPTMRCMPB;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:    INT_CFGSET = INT_SLEEPTMR;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      halSleepWithOptions(SLEEPMODE_WAKETIMER, gpioWakeBitMask);
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:    INT_SLEEPTMRCFG = INT_SLEEPTMRCFG_RESET; //disable all SleepTMR interrupts
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:    //If we didn't come out of sleep via a compare or overflow interrupt,
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:    //it was an abnormal sleep interruption; report the event.
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:    if(!sleepTimerInterruptOccurred) {
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      status = ST_SLEEP_INTERRUPTED;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      //Update duration to account for how long last sleep was.  Using the
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      if(sleepOverflowCount) {
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:        sleepOverflowCount--;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      sleepTimerInterruptOccurred = FALSE;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      if(sleepOverflowCount) {
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:        //enable sleeping for a full timer wrap
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:        INT_SLEEPTMRFLAG = INT_SLEEPTMRCMPB;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:        INT_SLEEPTMRCFG = INT_SLEEPTMRCMPB;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      } else if(!sleepOverflowCount && (*duration>0)){
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:        //enable sleeping for the remainder
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:        INT_SLEEPTMRFLAG = INT_SLEEPTMRCMPA;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:        INT_SLEEPTMRCFG = INT_SLEEPTMRCMPA;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:StStatus halSleepForQsWithOptions(int32u *duration, int32u gpioWakeBitMask)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:  return internalSleepForQs(TRUE, duration, gpioWakeBitMask);
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h:  //This is necessary here because halSleepForQsWithOptions returns an
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h:/** @brief Puts the microcontroller to sleep in a specified mode, allows
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * @param sleepMode  A microcontroller sleep mode.
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * the chip from deep sleep.  A high bit in the mask will enable waking
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * @sa ::SleepModes
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h:void halSleepWithOptions(SleepModes sleepMode, int32u gpioWakeBitMask);
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * @brief Uses the system timer to enter ::SLEEPMODE_WAKETIMER for
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * decremented to 0 after sleeping for the specified amount of time.  If an
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * interrupt occurs that brings the chip out of sleep, the function returns
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * ::ST_SLEEP_INTERRUPTED and the duration parameter reports the amount of
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * @note The maximum sleep time of the hardware is limited on STM32W108 platforms
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * to 48.5 days.  Any sleep duration greater than this limit will wake up
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * briefly (e.g. 16 microseconds) to reenable another sleep cycle.
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * micro should be placed into ::SLEEPMODE_WAKETIMER.  When the function returns,
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * sleep time request (normally the return value will be 0).
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * the chip from deep sleep.  A high bit in the mask will enable waking
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h:StStatus halSleepForQsWithOptions(int32u *duration, int32u gpioWakeBitMask);
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * @brief Provides access to assembly code which triggers idle sleep.
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h:void halInternalIdleSleep(void);
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h:/** @brief Puts the microcontroller to sleep in a specified mode.  This
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: *  internal function performs the actual sleep operation.  This function
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * @param sleepMode  A microcontroller sleep mode
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h:void halInternalSleep(SleepModes sleepMode);
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * @brief Obtains the events that caused the last wake from sleep.  The
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * - [30] = SleepSkipped
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * - [26] = PWRUP_SLEEPTMRWRAP
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * - [25] = PWRUP_SLEEPTMRCOMPB
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * - [24] = PWRUP_SLEEPTMRCOMPA
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * WakeInfoValid means that ::halSleepWithOptions (::halInternalSleep) has been called
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * this bit says the sleep code has been called since power on.
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * SleepSkipped means that the chip never left the running state.  Sleep can
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * control from the CPU to the power management state machine.  Sleep can
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * signal is set).  The net affect of skipping sleep is the Low Voltage
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * @return The events that caused the last wake from sleep. 
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/crt_stm32w108.c:void halSleepTimerIsr() __attribute__ ((weak, alias("Default_Handler")));
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/crt_stm32w108.c:  halSleepTimerIsr,          // 20
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/crt_stm32w108.c:  // reset type happens to be a deep sleep reset.  If the reset is not from
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/crt_stm32w108.c:  // deep sleep, then locals can be freely used
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/crt_stm32w108.c:  NVIC_IPR_7to4   = ((MED  <<NVIC_IPR_7to4_PRI_4_BIT) |      //Sleep Timer Handler
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/crt_stm32w108.c:  if((RESET_EVENT&RESET_DSLEEP) == RESET_DSLEEP) {
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/crt_stm32w108.c:    //of inside of the halInternalSleep code:
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/low_level_init.c:  // reset type happens to be a deep sleep reset.  If the reset is not from
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/low_level_init.c:  // deep sleep, then locals can be freely used
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/low_level_init.c:  NVIC_IPR_7to4   = ((MED  <<NVIC_IPR_7to4_PRI_4_BIT) |      //Sleep Timer Handler
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/low_level_init.c:  if((RESET_EVENT&RESET_DSLEEP) == RESET_DSLEEP) {
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/low_level_init.c:    //of inside of the halInternalSleep code:
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CLKEN                                       *((volatile int32u *)0x40000008u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CLKEN_REG                                   *((volatile int32u *)0x40000008u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CLKEN_ADDR                                  (0x40000008u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CLKEN_RESET                                 (0x00000002u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPTMR_CLK10KEN field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLK10KEN                            (0x00000002u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLK10KEN_MASK                       (0x00000002u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLK10KEN_BIT                        (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLK10KEN_BITS                       (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPTMR_CLK32KEN field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLK32KEN                            (0x00000001u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLK32KEN_MASK                       (0x00000001u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLK32KEN_BIT                        (0)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLK32KEN_BITS                       (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define REGEN_DSLEEP                                         *((volatile int32u *)0x40000014u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define REGEN_DSLEEP_REG                                     *((volatile int32u *)0x40000014u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define REGEN_DSLEEP_ADDR                                    (0x40000014u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define REGEN_DSLEEP_RESET                                   (0x00000001u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* REGEN_DSLEEP_FIELD field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define REGEN_DSLEEP_FIELD                           (0x00000001u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define REGEN_DSLEEP_FIELD_MASK                      (0x00000001u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define REGEN_DSLEEP_FIELD_BIT                       (0)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define REGEN_DSLEEP_FIELD_BITS                      (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* WAKE_SLEEPTMRWRAP field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define WAKE_SLEEPTMRWRAP                            (0x00000040u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define WAKE_SLEEPTMRWRAP_MASK                       (0x00000040u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define WAKE_SLEEPTMRWRAP_BIT                        (6)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define WAKE_SLEEPTMRWRAP_BITS                       (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* WAKE_SLEEPTMRCMPB field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define WAKE_SLEEPTMRCMPB                            (0x00000020u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define WAKE_SLEEPTMRCMPB_MASK                       (0x00000020u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define WAKE_SLEEPTMRCMPB_BIT                        (5)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define WAKE_SLEEPTMRCMPB_BITS                       (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* WAKE_SLEEPTMRCMPA field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define WAKE_SLEEPTMRCMPA                            (0x00000010u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define WAKE_SLEEPTMRCMPA_MASK                       (0x00000010u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define WAKE_SLEEPTMRCMPA_BIT                        (4)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define WAKE_SLEEPTMRCMPA_BITS                       (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* PWRUP_SLEEPTMRWRAP field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define PWRUP_SLEEPTMRWRAP                           (0x00000040u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define PWRUP_SLEEPTMRWRAP_MASK                      (0x00000040u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define PWRUP_SLEEPTMRWRAP_BIT                       (6)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define PWRUP_SLEEPTMRWRAP_BITS                      (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* PWRUP_SLEEPTMRCOMPB field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define PWRUP_SLEEPTMRCOMPB                          (0x00000020u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define PWRUP_SLEEPTMRCOMPB_MASK                     (0x00000020u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define PWRUP_SLEEPTMRCOMPB_BIT                      (5)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define PWRUP_SLEEPTMRCOMPB_BITS                     (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* PWRUP_SLEEPTMRCOMPA field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define PWRUP_SLEEPTMRCOMPA                          (0x00000010u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define PWRUP_SLEEPTMRCOMPA_MASK                     (0x00000010u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define PWRUP_SLEEPTMRCOMPA_BIT                      (4)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define PWRUP_SLEEPTMRCOMPA_BITS                     (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* RESET_DSLEEP field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define RESET_DSLEEP                                 (0x00000020u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define RESET_DSLEEP_MASK                            (0x00000020u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define RESET_DSLEEP_BIT                             (5)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define RESET_DSLEEP_BITS                            (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CFG                                         *((volatile int32u *)0x4000600Cu)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CFG_REG                                     *((volatile int32u *)0x4000600Cu)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CFG_ADDR                                    (0x4000600Cu)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CFG_RESET                                   (0x00000400u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPTMR_REVERSE field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_REVERSE                             (0x00001000u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_REVERSE_MASK                        (0x00001000u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_REVERSE_BIT                         (12)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_REVERSE_BITS                        (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPTMR_ENABLE field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_ENABLE                              (0x00000800u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_ENABLE_MASK                         (0x00000800u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_ENABLE_BIT                          (11)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_ENABLE_BITS                         (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPTMR_DBGPAUSE field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_DBGPAUSE                            (0x00000400u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_DBGPAUSE_MASK                       (0x00000400u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_DBGPAUSE_BIT                        (10)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_DBGPAUSE_BITS                       (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPTMR_CLKDIV field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLKDIV                              (0x000000F0u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLKDIV_MASK                         (0x000000F0u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLKDIV_BIT                          (4)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLKDIV_BITS                         (4)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPTMR_CLKSEL field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLKSEL                              (0x00000001u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLKSEL_MASK                         (0x00000001u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLKSEL_BIT                          (0)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLKSEL_BITS                         (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CNTH                                        *((volatile int32u *)0x40006010u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CNTH_REG                                    *((volatile int32u *)0x40006010u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CNTH_ADDR                                   (0x40006010u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CNTH_RESET                                  (0x00000000u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPTMR_CNTH_FIELD field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CNTH_FIELD                          (0x0000FFFFu)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CNTH_FIELD_MASK                     (0x0000FFFFu)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CNTH_FIELD_BIT                      (0)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CNTH_FIELD_BITS                     (16)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CNTL                                        *((volatile int32u *)0x40006014u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CNTL_REG                                    *((volatile int32u *)0x40006014u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CNTL_ADDR                                   (0x40006014u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CNTL_RESET                                  (0x00000000u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPTMR_CNTL_FIELD field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CNTL_FIELD                          (0x0000FFFFu)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CNTL_FIELD_MASK                     (0x0000FFFFu)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CNTL_FIELD_BIT                      (0)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CNTL_FIELD_BITS                     (16)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPAH                                       *((volatile int32u *)0x40006018u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPAH_REG                                   *((volatile int32u *)0x40006018u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPAH_ADDR                                  (0x40006018u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPAH_RESET                                 (0x0000FFFFu)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPTMR_CMPAH_FIELD field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPAH_FIELD                         (0x0000FFFFu)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPAH_FIELD_MASK                    (0x0000FFFFu)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPAH_FIELD_BIT                     (0)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPAH_FIELD_BITS                    (16)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPAL                                       *((volatile int32u *)0x4000601Cu)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPAL_REG                                   *((volatile int32u *)0x4000601Cu)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPAL_ADDR                                  (0x4000601Cu)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPAL_RESET                                 (0x0000FFFFu)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPTMR_CMPAL_FIELD field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPAL_FIELD                         (0x0000FFFFu)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPAL_FIELD_MASK                    (0x0000FFFFu)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPAL_FIELD_BIT                     (0)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPAL_FIELD_BITS                    (16)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPBH                                       *((volatile int32u *)0x40006020u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPBH_REG                                   *((volatile int32u *)0x40006020u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPBH_ADDR                                  (0x40006020u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPBH_RESET                                 (0x0000FFFFu)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPTMR_CMPBH_FIELD field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPBH_FIELD                         (0x0000FFFFu)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPBH_FIELD_MASK                    (0x0000FFFFu)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPBH_FIELD_BIT                     (0)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPBH_FIELD_BITS                    (16)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPBL                                       *((volatile int32u *)0x40006024u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPBL_REG                                   *((volatile int32u *)0x40006024u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPBL_ADDR                                  (0x40006024u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPBL_RESET                                 (0x0000FFFFu)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPTMR_CMPBL_FIELD field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPBL_FIELD                         (0x0000FFFFu)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPBL_FIELD_MASK                    (0x0000FFFFu)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPBL_FIELD_BIT                     (0)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPBL_FIELD_BITS                    (16)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define INT_SLEEPTMRFLAG                                     *((volatile int32u *)0x4000A014u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define INT_SLEEPTMRFLAG_REG                                 *((volatile int32u *)0x4000A014u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define INT_SLEEPTMRFLAG_ADDR                                (0x4000A014u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define INT_SLEEPTMRFLAG_RESET                               (0x00000000u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMRCMPB field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPB                             (0x00000004u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPB_MASK                        (0x00000004u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPB_BIT                         (2)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPB_BITS                        (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMRCMPA field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPA                             (0x00000002u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPA_MASK                        (0x00000002u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPA_BIT                         (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPA_BITS                        (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMRWRAP field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRWRAP                             (0x00000001u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRWRAP_MASK                        (0x00000001u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRWRAP_BIT                         (0)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRWRAP_BITS                        (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define INT_SLEEPTMRFORCE                                    *((volatile int32u *)0x4000A020u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define INT_SLEEPTMRFORCE_REG                                *((volatile int32u *)0x4000A020u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define INT_SLEEPTMRFORCE_ADDR                               (0x4000A020u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define INT_SLEEPTMRFORCE_RESET                              (0x00000000u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMRCMPB field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPB                             (0x00000004u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPB_MASK                        (0x00000004u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPB_BIT                         (2)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPB_BITS                        (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMRCMPA field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPA                             (0x00000002u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPA_MASK                        (0x00000002u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPA_BIT                         (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPA_BITS                        (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMRWRAP field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRWRAP                             (0x00000001u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRWRAP_MASK                        (0x00000001u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRWRAP_BIT                         (0)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRWRAP_BITS                        (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define INT_SLEEPTMRCFG                                      *((volatile int32u *)0x4000A054u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define INT_SLEEPTMRCFG_REG                                  *((volatile int32u *)0x4000A054u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define INT_SLEEPTMRCFG_ADDR                                 (0x4000A054u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define INT_SLEEPTMRCFG_RESET                                (0x00000000u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMRCMPB field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPB                             (0x00000004u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPB_MASK                        (0x00000004u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPB_BIT                         (2)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPB_BITS                        (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMRCMPA field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPA                             (0x00000002u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPA_MASK                        (0x00000002u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPA_BIT                         (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPA_BITS                        (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMRWRAP field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRWRAP                             (0x00000001u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRWRAP_MASK                        (0x00000001u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRWRAP_BIT                         (0)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRWRAP_BITS                        (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_MISSSLEEP field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_MISSSLEEP                                (0x00000010u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_MISSSLEEP_MASK                           (0x00000010u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_MISSSLEEP_BIT                            (4)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_MISSSLEEP_BITS                           (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPEVTENA field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define DWT_CTRL_SLEEPEVTENA                         (0x00080000u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define DWT_CTRL_SLEEPEVTENA_MASK                    (0x00080000u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define DWT_CTRL_SLEEPEVTENA_BIT                     (19)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define DWT_CTRL_SLEEPEVTENA_BITS                    (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define DWT_SLEEPCNT                                         *((volatile int32u *)0xE0001010u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define DWT_SLEEPCNT_REG                                     *((volatile int32u *)0xE0001010u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define DWT_SLEEPCNT_ADDR                                    (0xE0001010u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define DWT_SLEEPCNT_RESET                                   (0x00000000u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPCNT field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define DWT_SLEEPCNT_SLEEPCNT                        (0x000000FFu)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define DWT_SLEEPCNT_SLEEPCNT_MASK                   (0x000000FFu)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define DWT_SLEEPCNT_SLEEPCNT_BIT                    (0)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define DWT_SLEEPCNT_SLEEPCNT_BITS                   (8)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMR field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR                                 (0x00000010u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_MASK                            (0x00000010u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_BIT                             (4)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_BITS                            (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMR field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR                                 (0x00000010u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_MASK                            (0x00000010u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_BIT                             (4)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_BITS                            (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMR field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR                                 (0x00000010u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_MASK                            (0x00000010u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_BIT                             (4)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_BITS                            (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMR field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR                                 (0x00000010u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_MASK                            (0x00000010u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_BIT                             (4)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_BITS                            (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMR field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR                                 (0x00000010u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_MASK                            (0x00000010u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_BIT                             (4)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_BITS                            (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPDEEP field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SCS_SCR_SLEEPDEEP                            (0x00000004u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SCS_SCR_SLEEPDEEP_MASK                       (0x00000004u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SCS_SCR_SLEEPDEEP_BIT                        (2)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SCS_SCR_SLEEPDEEP_BITS                       (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPONEXIT field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SCS_SCR_SLEEPONEXIT                          (0x00000002u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SCS_SCR_SLEEPONEXIT_MASK                     (0x00000002u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SCS_SCR_SLEEPONEXIT_BIT                      (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SCS_SCR_SLEEPONEXIT_BITS                     (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* S_SLEEP field */
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define DEBUG_HCSR_S_SLEEP                           (0x00040000u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define DEBUG_HCSR_S_SLEEP_MASK                      (0x00040000u)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define DEBUG_HCSR_S_SLEEP_BIT                       (18)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define DEBUG_HCSR_S_SLEEP_BITS                      (1)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.ddf:sfr = "INT_MISS.INT_MISSSLEEP",                         "Memory",  0x4000A820,  4,        base=16,     bitMask=0x00000010
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.ddf:sfr = "INT_CFGSET.INT_SLEEPTMR",                        "Memory",  0xE000E100,  4,        base=16,     bitMask=0x00000010
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.ddf:sfr = "INT_CFGCLR.INT_SLEEPTMR",                        "Memory",  0xE000E180,  4,        base=16,     bitMask=0x00000010
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.ddf:sfr = "INT_PENDSET.INT_SLEEPTMR",                       "Memory",  0xE000E200,  4,        base=16,     bitMask=0x00000010
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.ddf:sfr = "INT_PENDCLR.INT_SLEEPTMR",                       "Memory",  0xE000E280,  4,        base=16,     bitMask=0x00000010
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.ddf:sfr = "INT_ACTIVE.INT_SLEEPTMR",                        "Memory",  0xE000E300,  4,        base=16,     bitMask=0x00000010
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/stm32w108/board.h: * @brief Perform board specific action to power down the system, usually before going to deep sleep.
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:// @brief Context save/restore for deep sleep using the PendSV exception.
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:// This file also contains a simple halInternalIdleSleep() function that
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:// executes just the WFI instruction for idle sleeping.
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:// When the STM32W108XX enters deep sleep, the hardware will actually remove power
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:// from the Cortex-M3 core (in Deep Sleep 0, power is not removed but the core
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:// must be properly restored such that execution can resume from the sleep code.
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:// As its last act, the deep sleep code will trigger the PendSV exception to
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:// perform a context save.  When the core is booted upon deep sleep exit, the
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:// RESET_EVENT register informs cstartup if the chip just exited deep sleep.
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:// was before deep sleep.
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:// and trigger sleeping through the 'WFI' instruction, or restore a
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:        WFI                   //all saved, trigger deep sleep
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:        // powered off or reset (depending on the deep sleep level).
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79://   void halInternalIdleSleep(void)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:// A simple internal function call (to be called from halSleep) for executing
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:// the WFI instruction and entering the simple, idle sleep state.
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:        __EXPORT__ halInternalIdleSleep
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:halInternalIdleSleep:
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:        WFI                    //trigger idle sleep
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/cstartup_M.s:        DCD     halSleepTimerIsr     ;;Sleep Timer Handler
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/cstartup_M.s:        PUBWEAK halSleepTimerIsr    
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/cstartup_M.s:halSleepTimerIsr   
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:  //Since the SleepTMR is the only timer maintained during deep sleep, it is
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:  INT_CFGCLR = INT_SLEEPTMR;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:      SLEEPTMR_CLKEN = 0;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:      SLEEPTMR_CLKEN = SLEEPTMR_CLK32KEN;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:    //Sleep timer configuration is the same for crystal and external clock
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:    SLEEPTMR_CFG = (SLEEPTMR_ENABLE            | //enable TMR
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:                   (0 << SLEEPTMR_DBGPAUSE_BIT)| //TMR paused when halted
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:                   (5 << SLEEPTMR_CLKDIV_BIT)  | //divide down to 1024Hz
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:                   (1 << SLEEPTMR_CLKSEL_BIT)) ; //select XTAL
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:    SLEEPTMR_CLKEN = SLEEPTMR_CLK10KEN;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:    SLEEPTMR_CFG = (SLEEPTMR_ENABLE            | //enable TMR
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:                   (0 << SLEEPTMR_DBGPAUSE_BIT)| //TMR paused when halted
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:                   (0 << SLEEPTMR_CLKDIV_BIT)  | //already 1024Hz
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:                   (0 << SLEEPTMR_CLKSEL_BIT)) ; //select SlowRC
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:  INT_SLEEPTMRFLAG = (INT_SLEEPTMRWRAP | INT_SLEEPTMRCMPA | INT_SLEEPTMRCMPB);
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:  INT_SLEEPTMRCFG = INT_SLEEPTMRCFG_RESET;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:  INT_CFGSET = INT_SLEEPTMR;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:/** @file hal/micro/cortexm3/sleep.c
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c: * @brief STM32W108 micro specific sleep functions.
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c://This "register" is only ever set by halInternalSleep.
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:// [30] = SleepSkipped
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:#define SLEEPSKIPPED_INTERNAL_WAKE_EVENT_BIT  30
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:void halInternalSleep(SleepModes sleepMode)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:  //the state here in case SLEEPMODE_NOTIMER is invoked, which would disable
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:  int32u SLEEPTMR_CLKEN_SAVED = SLEEPTMR_CLKEN;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:  //As such, it should be called from halSleepWithOptions() or from
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:  // halSleepForQsWithOptions() which configues the wake sources.
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:  switch(sleepMode)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:    case SLEEPMODE_NOTIMER:
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      //The sleep timer clock sources (both RC and XTAL) are turned off.
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      SLEEPTMR_CLKEN = 0;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      goto deepSleepCore;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:    case SLEEPMODE_WAKETIMER:
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      //The sleep timer clock sources remain running.  The RC is always
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      //is possible from both GPIO and the sleep timer.  System time
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      //is maintained.  The sleep timer is assumed to be configured
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      //      sleep timer properly.
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      if(INT_SLEEPTMRCFG&INT_SLEEPTMRWRAP) {
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        WAKE_SEL |= WAKE_SLEEPTMRWRAP;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      if(INT_SLEEPTMRCFG&INT_SLEEPTMRCMPB) {
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        WAKE_SEL |= WAKE_SLEEPTMRCMPB;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      if(INT_SLEEPTMRCFG&INT_SLEEPTMRCMPA) {
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        WAKE_SEL |= WAKE_SLEEPTMRCMPA;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      //fall into SLEEPMODE_MAINTAINTIMER's sleep code:
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:    case SLEEPMODE_MAINTAINTIMER:
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      //The sleep timer clock sources remain running.  The RC is always
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      //NOTE: System time is maintained without any sleep timer interrupts
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      //      because the hardware sleep timer counter is large enough
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:    // Core deep sleep code
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:deepSleepCore:
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      // Interrupts *must* be/stay disabled for DEEP SLEEP operation
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      // deep sleep.
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        boolean skipSleep = FALSE;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        // Only three register blocks keep power across deep sleep:
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        // All other register blocks lose their state across deep sleep:
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        // The sleep code will only save and restore registers where it is
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        int32u INT_SLEEPTMRCFG_SAVED = INT_SLEEPTMRCFG_REG;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //ST_CSR - fixed, restored by cstartup when exiting deep sleep
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //ST_RVR - fixed, restored by cstartup when exiting deep sleep
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //NVIC_IPR_3to0 - fixed, restored by cstartup when exiting deep sleep
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //NVIC_IPR_7to4 - fixed, restored by cstartup when exiting deep sleep
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //NVIC_IPR_11to8 - fixed, restored by cstartup when exiting deep sleep
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //NVIC_IPR_15to12 - fixed, restored by cstartup when exiting deep sleep
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //NVIC_IPR_19to16 - fixed, restored by cstartup when exiting deep sleep
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //SCS_CCR - fixed, restored by cstartup when exiting deep sleep
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //SCS_SHPR_7to4 - fixed, restored by cstartup when exiting deep sleep
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //SCS_SHPR_11to8 - fixed, restored by cstartup when exiting deep sleep
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //SCS_SHPR_15to12 - fixed, restored by cstartup when exiting deep sleep
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //SCS_SHCSR - fixed, restored by cstartup when exiting deep sleep
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //sometime while entering sleep, so we need to skip over sleeping
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //  SleepTMR CMPA, CMPB, Wrap
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          skipSleep = TRUE;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          skipSleep = TRUE;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          skipSleep = TRUE;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          skipSleep = TRUE;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //check for SleepTMR CMPA interrupt and if SleepTMR CMPA is wake source
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        if((INT_SLEEPTMR&INT_SLEEPTMRCMPA) && (WAKE_SEL&WAKE_SLEEPTMRCMPA)) {
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          skipSleep = TRUE;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          //log SleepTMR CMPA as a wake event
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //check for SleepTMR CMPB interrupt and if SleepTMR CMPB is wake source
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        if((INT_SLEEPTMR&INT_SLEEPTMRCMPB) && (WAKE_SEL&WAKE_SLEEPTMRCMPB)) {
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          skipSleep = TRUE;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          //log SleepTMR CMPB as a wake event
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //check for SleepTMR WRAP interrupt and if SleepTMR WRAP is wake source
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        if((INT_SLEEPTMR&INT_SLEEPTMRWRAP) && (WAKE_SEL&WAKE_SLEEPTMRWRAP)) {
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          skipSleep = TRUE;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          //log SleepTMR WRAP as a wake event
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          skipSleep = TRUE;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //only propagate across deep sleep the interrupts that are both
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          if( (WAKE_SEL&WAKE_SLEEPTMRCMPA) ||
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:              (WAKE_SEL&WAKE_SLEEPTMRCMPB) ||
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:              (WAKE_SEL&WAKE_SLEEPTMRWRAP) ) {
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:            wakeSourceInterruptMask |= INT_SLEEPTMR;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //disable watchdog while sleeping (since we can't reset it asleep)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //The chip is not allowed to enter a deep sleep mode (which could
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //chip that would get reset during deep sleep.  Therefore, a reset
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //connected).  But, we cannot induce deep sleep until CSYSPWRUPREQ/ACK
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //we can proceed into deep sleep.  The CSYSPWRUPACK_INHIBIT
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //until we are safely past and out of deep sleep.  The power management
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          //if there was a wake event, allow CSYSPWRUPACK and skip sleep
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:            skipSleep = TRUE;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        if(!skipSleep) {
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          //deep sleep since using the 24MHz XTAL could result in RAM
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          //sleeping.
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          //FogBugz 8858 states that we cannot go into deep-sleep when the
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          //REGEN_DSLEEP here.  This is hugely dangerous and
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          SCS_SCR |= SCS_SCR_SLEEPDEEP;      //enable deep sleep
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          SCS_ICSR |= SCS_ICSR_PENDSVSET;    //pend the context save and Dsleep
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          //I AM ASLEEP.  WHEN EXECUTION RESUMES, CSTARTUP WILL RESTORE TO HERE
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          //Record the fact that we skipped sleep
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          halInternalWakeEvent |= BIT32(SLEEPSKIPPED_INTERNAL_WAKE_EVENT_BIT);
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          //If this was a true deep sleep, we would have executed cstartup and
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          //PRIMASK would be set right now.  If we skipped sleep, PRIMASK is not
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //is necessary because if we don't execute an actual deep sleep cycle
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //we always mimick a real deep sleep as closely as possible and
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //of deep sleep.  (The interrupt dispatch code coming out of sleep
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        INT_SLEEPTMRFLAG = (INT_SLEEPTMRCMPA |
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:                            INT_SLEEPTMRCMPB |
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:                            INT_SLEEPTMRWRAP);
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //immediately restore the registers we saved before sleeping
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //so IRQ and SleepTMR capture can be reenabled as quickly as possible
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        SLEEPTMR_CLKEN_REG = SLEEPTMR_CLKEN_SAVED;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        INT_SLEEPTMRCFG_REG = INT_SLEEPTMRCFG_SAVED;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:                                   PWRUP_SLEEPTMRWRAP_MASK  |
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:                                   PWRUP_SLEEPTMRCOMPB_MASK |
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:                                   PWRUP_SLEEPTMRCOMPA_MASK ))
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //restart watchdog if it was running when we entered sleep
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //Pend any interrupts associated with deep sleep wake sources.  The
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //halSleepWithOptions.
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //The SleepTMR CMPA is linked to a real ISR.  If the SleepTMR CMPA
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        if( (INT_SLEEPTMRCFG&INT_SLEEPTMRCMPA) &&
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          INT_SLEEPTMRFORCE = INT_SLEEPTMRCMPA;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //The SleepTMR CMPB is linked to a real ISR.  If the SleepTMR CMPB
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        if( (INT_SLEEPTMRCFG&INT_SLEEPTMRCMPB) &&
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          INT_SLEEPTMRFORCE = INT_SLEEPTMRCMPB;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //The SleepTMR WRAP is linked to a real ISR.  If the SleepTMR WRAP
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        if( (INT_SLEEPTMRCFG&INT_SLEEPTMRWRAP) &&
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          INT_SLEEPTMRFORCE = INT_SLEEPTMRWRAP;
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      break; //and deep sleeping is done!
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:    case SLEEPMODE_IDLE:
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //disable watchdog while sleeping (since we can't reset it asleep)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        halInternalIdleSleep();
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //restart watchdog if it was running when we entered sleep
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      //Oops!  Invalid sleepMode parameter.
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:void halSleepWithOptions(SleepModes sleepMode, int32u gpioWakeBitMask)
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:  //wake sources are configured so do the actual sleeping
./output.txt:./cpu/stm32w108/hal/micro/cortexm3/sleep.c:  halInternalSleep(sleepMode);
./output.txt:./cpu/stm32w108/hal/micro/micro-common.h:  //This is necessary here because halSleepForQsWithOptions returns an
./output.txt:./cpu/stm32w108/hal/micro/micro-common.h:/** @brief Enumerations for the possible microcontroller sleep modes.
./output.txt:./cpu/stm32w108/hal/micro/micro-common.h: * - SLEEPMODE_RUNNING
./output.txt:./cpu/stm32w108/hal/micro/micro-common.h: * - SLEEPMODE_IDLE
./output.txt:./cpu/stm32w108/hal/micro/micro-common.h: * - SLEEPMODE_WAKETIMER
./output.txt:./cpu/stm32w108/hal/micro/micro-common.h: *     The sleep timer clock sources remain running.  The RC is always
./output.txt:./cpu/stm32w108/hal/micro/micro-common.h: *     is possible from both GPIO and the sleep timer.  System time
./output.txt:./cpu/stm32w108/hal/micro/micro-common.h: *     is maintained.  The sleep timer is assumed to be configured
./output.txt:./cpu/stm32w108/hal/micro/micro-common.h: * - SLEEPMODE_MAINTAINTIMER
./output.txt:./cpu/stm32w108/hal/micro/micro-common.h: *     The sleep timer clock sources remain running.  The RC is always
./output.txt:./cpu/stm32w108/hal/micro/micro-common.h: * - SLEEPMODE_NOTIMER
./output.txt:./cpu/stm32w108/hal/micro/micro-common.h: *     The sleep timer clock sources (both RC and XTAL) are turned off.
./output.txt:./cpu/stm32w108/hal/micro/micro-common.h:enum SleepModes
./output.txt:./cpu/stm32w108/hal/micro/micro-common.h:typedef int8u SleepModes;
./output.txt:./cpu/stm32w108/hal/micro/micro-common.h:  SLEEPMODE_RUNNING = 0,
./output.txt:./cpu/stm32w108/hal/micro/micro-common.h:  SLEEPMODE_IDLE = 1,
./output.txt:./cpu/stm32w108/hal/micro/micro-common.h:  SLEEPMODE_WAKETIMER = 2,
./output.txt:./cpu/stm32w108/hal/micro/micro-common.h:  SLEEPMODE_MAINTAINTIMER = 3,
./output.txt:./cpu/stm32w108/hal/micro/micro-common.h:  SLEEPMODE_NOTIMER = 4,
./output.txt:./cpu/stm32w108/dev/stm32w-radio.c:                                  ST_RadioSleep();                    \
./output.txt:./cpu/stm32w108/dev/stm32w-radio.c:    /* Put CPU in sleep mode. */
./output.txt:./cpu/stm32w108/dev/stm32w-radio.c:    halSleepWithOptions(SLEEPMODE_IDLE,0);
./output.txt:./cpu/stm32w108/dev/stm32w-radio.c:    ST_RadioSleep();
./output.txt:./cpu/stm32w108/sleep.h:/* Enter system in deep sleep 1 (core power domain is fully
./output.txt:./cpu/stm32w108/sleep.h: * powered down and sleep timer is active).
./output.txt:./cpu/stm32w108/sleep.h:void sleep_seconds(int seconds);
./output.txt:./cpu/stm32w108/simplemac/include/phy-library.h: * This function must be called once after chip reset or wake from deep sleep.
./output.txt:./cpu/stm32w108/simplemac/include/phy-library.h: * sleep.
./output.txt:./cpu/stm32w108/simplemac/include/phy-library.h: * ST_RadioSleep().
./output.txt:./cpu/stm32w108/simplemac/include/phy-library.h:void ST_RadioSleep(void);
./output.txt:./cpu/stm32w108/simplemac/include/phy-library.h: * If the radio is asleep this function will wake it to perform channel
./output.txt:./cpu/stm32w108/simplemac/include/phy-library.h: * calibration and then return it to sleep before exiting.
./output.txt:./cpu/stm32w108/board-sensors.h: * Useful when entering in sleep mode, since all system
./output.txt:./cpu/stm32w108/board-sensors.h: * in deep sleep mode.
./output.txt:./cpu/stm32w108/clock.c:sleep_seconds(int seconds)
./output.txt:./cpu/stm32w108/clock.c:  halSleepForQsWithOptions(&quarter_seconds, 0);
./output.txt:./cpu/cc253x/sfr-bits.h:/* SLEEPCMD and SLEEPSTA */
./output.txt:./cpu/cc253x/sfr-bits.h:#define SLEEP_OSC32K_CALDIS  0x80
./output.txt:./cpu/cc253x/sfr-bits.h:#define SLEEP_XOSC_STB       0x40
./output.txt:./cpu/cc253x/sfr-bits.h:#define SLEEP_HFRC_STB       0x20
./output.txt:./cpu/cc253x/sfr-bits.h:#define SLEEP_RST1           0x10 /* SLEEPSTA only */
./output.txt:./cpu/cc253x/sfr-bits.h:#define SLEEP_RST0           0x08 /* SLEEPSTA only */
./output.txt:./cpu/cc253x/sfr-bits.h:#define SLEEP_OSC_PD         0x04
./output.txt:./cpu/cc253x/sfr-bits.h:#define SLEEP_MODE1          0x02
./output.txt:./cpu/cc253x/sfr-bits.h:#define SLEEP_MODE0          0x01
./output.txt:./cpu/cc253x/dev/dma.h:#define DMA_T_ST        11 /* Sleep Timer compare */
./output.txt:./cpu/cc253x/dev/clock-isr.h: *         Declaration of the Sleep timer ISR, used by the clock module
./output.txt:./cpu/cc253x/dev/clock.c:/* Sleep timer runs on the 32k RC osc. */
./output.txt:./cpu/cc253x/dev/clock.c:volatile __bit sleep_flag;
./output.txt:./cpu/cc253x/dev/clock.c: * TI examples appear to be writing to SLEEPCMD, initialising hardware in a
./output.txt:./cpu/cc253x/dev/clock.c: * However, the datasheet claims that those bits in SLEEPCMD are reserved
./output.txt:./cpu/cc253x/dev/clock.c:  sleep_flag = 1;
./output.txt:./cpu/cc253x/cc253x.h:#define ST_VECTOR        5  /* Sleep Timer compare */
./output.txt:./cpu/cc253x/cc253x.h:  SBIT(STIE,     0xA8, 5); /* Sleep Timer interrupt enable */
./output.txt:./cpu/cc253x/cc253x.h:  SBIT(STIF,     0xC0, 7); /* Sleep Timer interrupt flag */
./output.txt:./cpu/cc253x/cc253x.h:/* Sleep Timer */
./output.txt:./cpu/cc253x/cc253x.h:SFR(ST0,       0x95); /* Sleep Timer 0 */
./output.txt:./cpu/cc253x/cc253x.h:SFR(ST1,       0x96); /* Sleep Timer 1 */
./output.txt:./cpu/cc253x/cc253x.h:SFR(ST2,       0x97); /* Sleep Timer 2 */
./output.txt:./cpu/cc253x/cc253x.h:SFR(STLOAD,    0xAD); /* Sleep-timer load status */
./output.txt:./cpu/cc253x/cc253x.h:SFR(SLEEPCMD,  0xBE); /* Sleep-mode control command */
./output.txt:./cpu/cc253x/cc253x.h:SFR(SLEEPSTA,  0x9D); /* Sleep-mode control status */
./output.txt:./cpu/cc253x/cc253x.h:SFRX(SRCRC,      0x6262); /* Sleep reset CRC */
./output.txt:./cpu/cc253x/cc253x.h:SFRX(STCC,       0x62B0); /* Sleep Timer capture control */
./output.txt:./cpu/cc253x/cc253x.h:SFRX(STCS,       0x62B1); /* Sleep Timer capture status */
./output.txt:./cpu/cc253x/cc253x.h:SFRX(STCV0,      0x62B2); /* Sleep Timer capture value byte 0 */
./output.txt:./cpu/cc253x/cc253x.h:SFRX(STCV1,      0x62B3); /* Sleep Timer capture value byte 1 */
./output.txt:./cpu/cc253x/cc253x.h:SFRX(STCV2,      0x62B4); /* Sleep Timer capture value byte 2 */
./output.txt:./cpu/cc253x/cc253x.h:SFRX(X_ST0,       0x7095); /* Sleep Timer 0 */
./output.txt:./cpu/cc253x/cc253x.h:SFRX(X_ST1,       0x7096); /* Sleep Timer 1 */
./output.txt:./cpu/cc253x/cc253x.h:SFRX(X_ST2,       0x7097); /* Sleep Timer 2 */
./output.txt:./cpu/cc253x/cc253x.h:SFRX(X_SLEEPSTA,  0x709D); /* Sleep-mode control status */
./output.txt:./cpu/cc253x/cc253x.h:SFRX(X_STLOAD,    0x70AD); /* Sleep-timer load status */
./output.txt:./cpu/cc253x/cc253x.h:SFRX(X_SLEEPCMD,  0x70BE); /* Sleep-mode control command */
./output.txt:./cpu/arm/at91sam7s/AT91SAM7S256.h:#define AT91C_ADC_SLEEP       (0x1 <<  5) // (ADC) Sleep Mode
./output.txt:./cpu/arm/at91sam7s/AT91SAM7S256.h:#define 	AT91C_ADC_SLEEP_NORMAL_MODE          (0x0 <<  5) // (ADC) Normal Mode
./output.txt:./cpu/arm/at91sam7s/AT91SAM7S256.h:#define 	AT91C_ADC_SLEEP_MODE                 (0x1 <<  5) // (ADC) Sleep Mode
./output.txt:./cpu/arm/at91sam7s/AT91SAM7S128.h:#define AT91C_ADC_SLEEP       (0x1 <<  5) // (ADC) Sleep Mode
./output.txt:./cpu/arm/at91sam7s/AT91SAM7S128.h:#define 	AT91C_ADC_SLEEP_NORMAL_MODE          (0x0 <<  5) // (ADC) Normal Mode
./output.txt:./cpu/arm/at91sam7s/AT91SAM7S128.h:#define 	AT91C_ADC_SLEEP_MODE                 (0x1 <<  5) // (ADC) Sleep Mode
./output.txt:./cpu/arm/at91sam7s/AT91SAM7S64.h:#define AT91C_ADC_SLEEP       (0x1 <<  5) // (ADC) Sleep Mode
./output.txt:./cpu/arm/at91sam7s/AT91SAM7S64.h:#define 	AT91C_ADC_SLEEP_NORMAL_MODE          (0x0 <<  5) // (ADC) Normal Mode
./output.txt:./cpu/arm/at91sam7s/AT91SAM7S64.h:#define 	AT91C_ADC_SLEEP_MODE                 (0x1 <<  5) // (ADC) Sleep Mode
./output.txt:./cpu/arm/at91sam7s/Makefile.at91sam7s:	$(OPENOCD) -s $(OPENOCD_DIR) -f $(OPENOCD_CFG) -c init -c "halt;mww 0xffffff64 0x5a000004;sleep 250;mww 0xffffff64 0x5a002004; sleep 250;flash probe 0;flash write_bank 0 $< 0x0;reset run;sleep 500;exit"
./output.txt:./cpu/arm/at91sam7s/openocd/openocd_reset:sleep 500
./output.txt:./cpu/arm/at91sam7s/openocd/openocd_flash:sleep 250
./output.txt:./cpu/arm/at91sam7s/openocd/openocd_flash:sleep 250
./output.txt:./cpu/arm/at91sam7s/openocd/openocd_flash:sleep 500
./output.txt:./cpu/arm/stm32f103/stm32f10x_map.h:#define  PWR_CR_LPDS                         ((u16)0x0001)     /* Low-Power Deepsleep */
./output.txt:./cpu/arm/stm32f103/stm32f10x_map.h:#define  PWR_CR_PDDS                         ((u16)0x0002)     /* Power Down Deepsleep */
./output.txt:./cpu/arm/stm32f103/stm32f10x_map.h:#define  SCB_SCR_SLEEPONEXIT                 ((u8)0x02)               /* Sleep on exit bit */
./output.txt:./cpu/arm/stm32f103/stm32f10x_map.h:#define  SCB_SCR_SLEEPDEEP                   ((u8)0x04)               /* Sleep deep bit */
./output.txt:./cpu/arm/stm32f103/stm32f10x_map.h:#define  CAN_MCR_SLEEP                       ((u16)0x0002)            /* Sleep Mode Request */
./output.txt:./cpu/arm/stm32f103/stm32f10x_map.h:#define  CAN_MSR_SLAK                        ((u16)0x0002)            /* Sleep Acknowledge */
./output.txt:./cpu/arm/stm32f103/stm32f10x_map.h:#define  CAN_MSR_SLAKI                       ((u16)0x0010)            /* Sleep Acknowledge Interrupt */
./output.txt:./cpu/arm/stm32f103/stm32f10x_map.h:#define  CAN_IER_SLKIE                       ((u32)0x00020000)        /* Sleep Interrupt Enable */
./output.txt:./cpu/arm/stm32f103/stm32f10x_map.h:#define  DBGMCU_CR_DBG_SLEEP                 ((u32)0x00000001)        /* Debug Sleep Mode */
./output.txt:./cpu/arm/stm32f103/stm32f10x_nvic.h:#define NVIC_LP_SLEEPDEEP            ((u8)0x04)
./output.txt:./cpu/arm/stm32f103/stm32f10x_nvic.h:#define NVIC_LP_SLEEPONEXIT          ((u8)0x02)
./output.txt:./cpu/arm/stm32f103/stm32f10x_nvic.h:                        ((LP) == NVIC_LP_SLEEPDEEP) || \
./output.txt:./cpu/arm/stm32f103/stm32f10x_nvic.h:                        ((LP) == NVIC_LP_SLEEPONEXIT))
Binary file ./.git/index matches
./cpu/cc2430/rtimer-arch.c: *         clock and etimer are using the sleep timer on the cc2430
./cpu/cc2430/dev/dma.h:#define DMA_T_ST        11 /* Sleep Timer compare */
./cpu/cc2430/dev/clock.c:/* Sleep timer runs on the 32k RC osc. */
./cpu/cc2430/dev/clock.c:volatile __bit sleep_flag;
./cpu/cc2430/dev/clock.c:/* Used in sleep timer interrupt for calculating the next interrupt time */
./cpu/cc2430/dev/clock.c:  IEN0_STIE = 1; /* IEN0.STIE acknowledge Sleep Timer Interrupt */
./cpu/cc2430/dev/clock.c:   * If the Sleep timer throws an interrupt while we are powering down to
./cpu/cc2430/dev/clock.c:   * PM1, we need to abort the power down. Clear SLEEP.MODE, this will signal
./cpu/cc2430/dev/clock.c:  SLEEP &= 0xFC;
./cpu/cc2430/dev/clock.c:  sleep_flag = 1;
./cpu/cc2430/dev/cc2430_rf.c:  SLEEP &= ~OSC_PD; /*Osc on*/
./cpu/cc2430/dev/cc2430_rf.c:  while((SLEEP & XOSC_STB) == 0); /*wait for power up*/
./cpu/cc2430/cc2430_sfr.h:__sfr __at (0xBE)   SLEEP;
./cpu/cc2430/cc2430_sfr.h:#define SLEEP_MODE1	0x02
./cpu/cc2430/cc2430_sfr.h:#define SLEEP_MODE0	0x01
./cpu/avr/rtimer-arch.c:#if RDC_CONF_MCU_SLEEP
./cpu/avr/rtimer-arch.c:rtimer_arch_sleep(rtimer_clock_t howlong)
./cpu/avr/rtimer-arch.c:/* Deep Sleep for howlong rtimer ticks. This will stop all timers except
./cpu/avr/rtimer-arch.c: * precision but smaller maximum sleep time.
./cpu/avr/rtimer-arch.c: * Here a maximum 128msec (contikimac 8Hz channel check sleep) is assumed.
./cpu/avr/rtimer-arch.c: * The rtimer and system clocks are adjusted to reflect the sleep time.
./cpu/avr/rtimer-arch.c:#include <avr/sleep.h>
./cpu/avr/rtimer-arch.c:	set_sleep_mode(SLEEP_MODE_PWR_SAVE);
./cpu/avr/rtimer-arch.c:#if 0    //Prescale by 1024 -   32 ticks/sec, 8 seconds max sleep
./cpu/avr/rtimer-arch.c:#elif 0  // Prescale by 256 -  128 ticks/sec, 2 seconds max sleep
./cpu/avr/rtimer-arch.c:#elif 0  // Prescale by 128 -  256 ticks/sec, 1 seconds max sleep
./cpu/avr/rtimer-arch.c:#elif 0  // Prescale by  64 -  512 ticks/sec, 500 msec max sleep
./cpu/avr/rtimer-arch.c:#elif 1  // Prescale by  32 - 1024 ticks/sec, 250 msec max sleep
./cpu/avr/rtimer-arch.c:#elif 0  // Prescale by   8 - 4096 ticks/sec, 62.5 msec max sleep
./cpu/avr/rtimer-arch.c:#else    // No Prescale -    32768 ticks/sec, 7.8 msec max sleep
./cpu/avr/rtimer-arch.c:/* Enable TIMER2 output compare interrupt, sleep mode and sleep */
./cpu/avr/rtimer-arch.c:	if (OCR2A) sleep_mode();
./cpu/avr/rtimer-arch.c:/* Disable sleep mode after wakeup, so random code cant trigger sleep */
./cpu/avr/rtimer-arch.c:/* Adjust clock.c for the time spent sleeping */
./cpu/avr/rtimer-arch.c:#endif /* RDC_CONF_MCU_SLEEP */
./cpu/avr/watchdog.c: * It should be disabled during sleep (unless used for wakeup) since
./cpu/avr/rtimer-arch.h:void rtimer_arch_sleep(rtimer_clock_t howlong);
./cpu/avr/dev/clock-avr.h:  while the 1284p is sleeping. The Jackdaw has pads for a crystal. The crystal
./cpu/avr/dev/clock-avr.h:  The 1284p routine also uses TIMER2 to sleep a variable number of seconds.
./cpu/avr/dev/lanc111.c:     * becomes zero. We sleep 63 ms before each poll and
./cpu/avr/dev/lanc111.c:        NutSleep(63);
./cpu/avr/dev/lanc111.c:    NutSleep(63);
./cpu/avr/dev/lanc111.c:    NutSleep(63);
./cpu/avr/dev/lanc111.c:            NutSleep(63);
./cpu/avr/dev/lanc111.c:        NutSleep(63);
./cpu/avr/dev/lanc111.c:      /*NutSleep(1000);*/
./cpu/avr/dev/lanc111.c:    //NutSleep(500);
./cpu/avr/dev/lanc111.c:    //NutSleep(500);
./cpu/avr/dev/rtlregs.h:#define NIC_CONFIG3_SLEEP   0x04 /*!< \brief Sleep mode */
./cpu/avr/dev/rs232.h: *             The return value of the input handler affects the sleep
./cpu/avr/dev/rs232.h: *             is kept sleeping.
./cpu/avr/dev/rtl8019.c:     * Disable sleep and power down.
./cpu/avr/dev/rtl8019.c:    /*    NutSleep(WAIT500);*/
./cpu/avr/dev/rtl8019.c:    /*    NutSleep(WAIT500);*/
./cpu/avr/dev/clock.c:/* sleepseconds is the number of seconds sleeping since startup, available globally */
./cpu/avr/dev/clock.c:long sleepseconds;
./cpu/avr/dev/clock.c: * Typically used to add ticks after an MCU sleep
./cpu/avr/dev/clock.c:    sleepseconds++;
./cpu/avr/dev/usb/usb_task.c:#include <avr/sleep.h>
./cpu/avr/dev/usb/usb_task.c: *   \brief Spare function to handle sleep mode.
./cpu/avr/dev/usb/usb_task.c:   set_sleep_mode(SLEEP_MODE_PWR_DOWN);
./cpu/avr/dev/usb/usb_task.c:   sleep_mode();
./cpu/avr/radio/rf230/radio.c:    TIME_SLEEP_TO_TRX_OFF            = 880, /**<  Transition time from SLEEP to TRX_OFF. */
./cpu/avr/radio/rf230/radio.c:bool radio_is_sleeping(void);
./cpu/avr/radio/rf230/radio.c: *                          be changed (SLEEP).
./cpu/avr/radio/rf230/radio.c:    if (radio_is_sleeping() == true){
./cpu/avr/radio/rf230/radio.c: *                          device is sleeping.
./cpu/avr/radio/rf230/radio.c:    if (radio_is_sleeping() == true){
./cpu/avr/radio/rf230/radio.c: *  \retval RADIO_WRONG_STATE This function cannot be called in the SLEEP state.
./cpu/avr/radio/rf230/radio.c:    /* Ensure that the radio transceiver is not sleeping. */
./cpu/avr/radio/rf230/radio.c:    if (radio_is_sleeping() == true){
./cpu/avr/radio/rf230/radio.c: *  \note This function can not be called from P_ON or SLEEP. This is ensured
./cpu/avr/radio/rf230/radio.c: *  \note This function can not be called from P_ON or SLEEP. This is ensured
./cpu/avr/radio/rf230/radio.c: *  \retval RADIO_WRONG_STATE The device is sleeping.
./cpu/avr/radio/rf230/radio.c:    if (radio_is_sleeping() == true){
./cpu/avr/radio/rf230/radio.c: *  \note This function can not be called from P_ON or SLEEP. This is ensured
./cpu/avr/radio/rf230/radio.c: *                  has been taken to SLEEP and awaken again.
./cpu/avr/radio/rf230/radio.c:        /*Select to change the CLKM frequency directly or after returning from SLEEP.*/
./cpu/avr/radio/rf230/radio.c: *                                 that the controller could be sleeping.
./cpu/avr/radio/rf230/radio.c: *                                 could be sleeping since the CLKM pin is
./cpu/avr/radio/rf230/radio.c:/** \brief  This function checks if the radio transceiver is sleeping.
./cpu/avr/radio/rf230/radio.c: *  \retval     true    The radio transceiver is in SLEEP or one of the *_NOCLK
./cpu/avr/radio/rf230/radio.c: *  \retval     false   The radio transceiver is not sleeping.
./cpu/avr/radio/rf230/radio.c:bool radio_is_sleeping(void)
./cpu/avr/radio/rf230/radio.c:    bool sleeping = false;
./cpu/avr/radio/rf230/radio.c:    /* The radio transceiver will be at SLEEP or one of the *_NOCLK states only if */
./cpu/avr/radio/rf230/radio.c:        sleeping = true;
./cpu/avr/radio/rf230/radio.c:    return sleeping;
./cpu/avr/radio/rf230/radio.c:    if (radio_is_sleeping() == true){
./cpu/avr/radio/rf230/radio.c:/** \brief  This function will put the radio transceiver to sleep.
./cpu/avr/radio/rf230/radio.c: *  \retval    RADIO_SUCCESS          Sleep mode entered successfully.
./cpu/avr/radio/rf230/radio.c:radio_enter_sleep_mode(void)
./cpu/avr/radio/rf230/radio.c:    if (radio_is_sleeping() == true){
./cpu/avr/radio/rf230/radio.c:    radio_status_t enter_sleep_status = RADIO_TIMED_OUT;
./cpu/avr/radio/rf230/radio.c:        /* Enter Sleep. */
./cpu/avr/radio/rf230/radio.c:        enter_sleep_status = RADIO_SUCCESS;
./cpu/avr/radio/rf230/radio.c:    return enter_sleep_status;
./cpu/avr/radio/rf230/radio.c:/** \brief  This function will take the radio transceiver from sleep mode and
./cpu/avr/radio/rf230/radio.c: *  \retval    RADIO_SUCCESS          Left sleep mode and entered TRX_OFF state.
./cpu/avr/radio/rf230/radio.c:radio_leave_sleep_mode(void)
./cpu/avr/radio/rf230/radio.c:    /* Check if the radio transceiver is actually sleeping. */
./cpu/avr/radio/rf230/radio.c:    if (radio_is_sleeping() == false){
./cpu/avr/radio/rf230/radio.c:    delay_us(TIME_SLEEP_TO_TRX_OFF);
./cpu/avr/radio/rf230/radio.c:    radio_status_t leave_sleep_status = RADIO_TIMED_OUT;
./cpu/avr/radio/rf230/radio.c:        leave_sleep_status = RADIO_SUCCESS;
./cpu/avr/radio/rf230/radio.c:    return leave_sleep_status;
./cpu/avr/radio/rf230/radio.c: *          its states, except for the SLEEP state.
./cpu/avr/radio/rf230/radio.c: *                          SLEEP state.
./cpu/avr/radio/rf230/radio.c:    if (radio_is_sleeping() == true){
./cpu/avr/radio/rf230/radio.h:radio_status_t radio_enter_sleep_mode( void );
./cpu/avr/radio/rf230/radio.h:radio_status_t radio_leave_sleep_mode( void );
./cpu/avr/radio/rf230/at86rf230_registermap.h:/** Constant SLEEP for sub-register @ref SR_TRX_STATUS */
./cpu/avr/radio/rf230/at86rf230_registermap.h:#define SLEEP                    (15)
./cpu/avr/radio/ieee-manager/ieee-15-4-manager.h:    int (* sleep)(void);
./cpu/avr/radio/ieee-manager/ieee-15-4-manager.c:  return radio_leave_sleep_mode();
./cpu/avr/radio/ieee-manager/ieee-15-4-manager.c:sleep(void)
./cpu/avr/radio/ieee-manager/ieee-15-4-manager.c:  /* Sleep the radio. */
./cpu/avr/radio/ieee-manager/ieee-15-4-manager.c:  return radio_enter_sleep_mode();
./cpu/avr/radio/ieee-manager/ieee-15-4-manager.c:  pieee_15_4_manager->sleep = sleep;
./cpu/avr/radio/rf230bb/halbb.c:    /*IO Specific Initialization - sleep and reset pins. */
./cpu/avr/radio/rf230bb/halbb.c:    /*IO Specific Initialization - sleep and reset pins. */
./cpu/avr/radio/rf230bb/rf230bb.c:#define RADIOSLEEPSWHENOFF 1
./cpu/avr/radio/rf230bb/rf230bb.c:    TIME_SLEEP_TO_TRX_OFF            = 880, /**<  Transition time from SLEEP to TRX_OFF. */
./cpu/avr/radio/rf230bb/rf230bb.c: *                                 that the controller could be sleeping.
./cpu/avr/radio/rf230bb/rf230bb.c: *                                 could be sleeping since the CLKM pin is
./cpu/avr/radio/rf230bb/rf230bb.c:/** \brief  This function checks if the radio transceiver is sleeping.
./cpu/avr/radio/rf230bb/rf230bb.c: *  \retval     true    The radio transceiver is in SLEEP or one of the *_NOCLK
./cpu/avr/radio/rf230bb/rf230bb.c: *  \retval     false   The radio transceiver is not sleeping.
./cpu/avr/radio/rf230bb/rf230bb.c:static bool radio_is_sleeping(void)
./cpu/avr/radio/rf230bb/rf230bb.c:    bool sleeping = false;
./cpu/avr/radio/rf230bb/rf230bb.c:    /* The radio transceiver will be at SLEEP or one of the *_NOCLK states only if */
./cpu/avr/radio/rf230bb/rf230bb.c:        sleeping = true;
./cpu/avr/radio/rf230bb/rf230bb.c:    return sleeping;
./cpu/avr/radio/rf230bb/rf230bb.c: *          its states, except for the SLEEP state.
./cpu/avr/radio/rf230bb/rf230bb.c:    delay_us(2*TIME_SLEEP_TO_TRX_OFF);
./cpu/avr/radio/rf230bb/rf230bb.c://  delay_us(TIME_SLEEP_TO_TRX_OFF+TIME_SLEEP_TO_TRX_OFF/2);
./cpu/avr/radio/rf230bb/rf230bb.c:#if RADIOSLEEPSWHENOFF
./cpu/avr/radio/rf230bb/rf230bb.c:  /* Sleep Radio */
./cpu/avr/radio/rf230bb/rf230bb.c:    PRINTF("rf230_set_txpower:Sleeping");  //happens with cxmac
./cpu/avr/radio/rf230bb/rf230bb.c:   * (JTAG, WDT, Brownout) the radio may be sleeping. It can enter an uncertain
./cpu/avr/radio/rf230bb/rf230bb.c:  delay_us(2*TIME_SLEEP_TO_TRX_OFF);
./cpu/avr/radio/rf230bb/rf230bb.c:  /* If radio is sleeping we have to turn it on first */
./cpu/avr/radio/rf230bb/rf230bb.c:    delay_us(2*TIME_SLEEP_TO_TRX_OFF); //extra delay depends on board capacitance
./cpu/avr/radio/rf230bb/rf230bb.c://	delay_us(TIME_SLEEP_TO_TRX_OFF+TIME_SLEEP_TO_TRX_OFF/2);
./cpu/avr/radio/rf230bb/rf230bb.c:		PRINTF("rf230_get_txpower:Sleeping");
./cpu/avr/radio/rf230bb/rf230bb.c:    if (hal_get_slptr()) {  //should not be sleeping!
./cpu/avr/radio/rf230bb/atmega128rfa1_registermap.h:/** Constant SLEEP for sub-register @ref SR_TRX_STATUS */
./cpu/avr/radio/rf230bb/atmega128rfa1_registermap.h:#define SLEEP                    (15)
./cpu/avr/radio/rf230bb/at86rf230_registermap.h:/** Constant SLEEP for sub-register @ref SR_TRX_STATUS */
./cpu/avr/radio/rf230bb/at86rf230_registermap.h:#define SLEEP                    (15)
./cpu/avr/radio/mac/sicslowmac.c: * end nodes to sleep.
./cpu/avr/radio/mac/sicslowmac.c: * end nodes to sleep.
./cpu/avr/radio/mac/sicslowmac.c:mac_sleep(void)
./cpu/mc1322x/contiki-crm.c:void sleep(uint32_t opts, uint32_t mode)
./cpu/mc1322x/contiki-crm.c:	/* the maca must be off before going to sleep */
./cpu/mc1322x/contiki-crm.c:	*CRM_SLEEP_CNTL = opts;
./cpu/mc1322x/contiki-crm.c:	*CRM_SLEEP_CNTL = (opts | mode);
./cpu/mc1322x/contiki-crm.c:	/* wait for the sleep cycle to complete */
./cpu/mc1322x/contiki-crm.c:        /* write 1 to sleep_sync --- this clears the bit (it's a r1wc bit) and powers down */
./cpu/mc1322x/contiki-crm.c:	/* now we are asleep */
./cpu/mc1322x/contiki-crm.c:        /* write 1 to sleep_sync --- this clears the bit (it's a r1wc bit) and finishes the wakeup */
./cpu/mc1322x/tests/Makefile:           sleep \
./cpu/mc1322x/tests/config.h:/* sleep */
./cpu/mc1322x/tests/sleep.c:	putstr("sleep test\n\r");
./cpu/mc1322x/tests/sleep.c:	/* radio must be OFF before sleeping */
./cpu/mc1322x/tests/sleep.c:	/* go to sleep */
./cpu/mc1322x/tests/sleep.c://	*CRM_SLEEP_CNTL = 1; /* hibernate, RAM page 0 only, don't retain state, don't power GPIO */ /* approx. 2kHz = 2.0uA */
./cpu/mc1322x/tests/sleep.c://	*CRM_SLEEP_CNTL = 0x41; /* hibernate, RAM page 0 only, retain state, don't power GPIO */ /* approx. 2kHz = 10.0uA */
./cpu/mc1322x/tests/sleep.c://	*CRM_SLEEP_CNTL = 0x51; /* hibernate, RAM page 0&1 only, retain state, don't power GPIO */ /* approx. 2kHz = 11.7uA */
./cpu/mc1322x/tests/sleep.c://	*CRM_SLEEP_CNTL = 0x61; /* hibernate, RAM page 0,1,2 only, retain state, don't power GPIO */ /* approx. 2kHz = 13.9uA */
./cpu/mc1322x/tests/sleep.c:	*CRM_SLEEP_CNTL = 0x71; /* hibernate, all RAM pages, retain state, don't power GPIO */ /* approx. 2kHz = 16.1uA */
./cpu/mc1322x/tests/sleep.c://	*CRM_SLEEP_CNTL = 0xf1; /* hibernate, all RAM pages, retain state,       power GPIO */ /* consumption depends on GPIO hookup */
./cpu/mc1322x/tests/sleep.c://	*CRM_SLEEP_CNTL = 2; /* doze     , RAM page 0 only, don't retain state, don't power GPIO */ /* approx. 69.2 uA */
./cpu/mc1322x/tests/sleep.c://	*CRM_SLEEP_CNTL = 0x42; /* doze     , RAM page 0 only, retain state, don't power GPIO */ /* approx. 77.3uA */
./cpu/mc1322x/tests/sleep.c://	*CRM_SLEEP_CNTL = 0x52; /* doze     , RAM page 0&1 only, retain state, don't power GPIO */ /* approx. 78.9uA */
./cpu/mc1322x/tests/sleep.c://	*CRM_SLEEP_CNTL = 0x62; /* doze     , RAM page 0,1,2 only, retain state, don't power GPIO */ /* approx. 81.2uA */
./cpu/mc1322x/tests/sleep.c://	*CRM_SLEEP_CNTL = 0x72; /* doze     , all RAM pages, retain state, don't power GPIO */ /* approx. 83.4uA - possibly with periodic refresh*/
./cpu/mc1322x/tests/sleep.c://	*CRM_SLEEP_CNTL = 0xf2; /* doze     , all RAM pages, retain state,       power GPIO */ /* consumption depends on GPIO hookup */
./cpu/mc1322x/tests/sleep.c:	/* wait for the sleep cycle to complete */
./cpu/mc1322x/tests/sleep.c:	/* write 1 to sleep_sync --- this clears the bit (it's a r1wc bit) and powers down */
./cpu/mc1322x/tests/sleep.c:	/* asleep */
./cpu/mc1322x/tests/sleep.c:	/* write 1 to sleep_sync --- this clears the bit (it's a r1wc bit) and finishes wakeup */
./cpu/mc1322x/README.subtree:For instance, if you need a routine called sleep, but libmc1322x
./cpu/mc1322x/README.subtree:doesn't have that yet, you could implement sleep in
./cpu/mc1322x/doc/ws-dis:    3e00:	455f4753 	ldrbmi	r4, [pc, #-1875]	; 36b5 <CRM_GoToSleep+0x69>
./cpu/mc1322x/doc/ws-dis:    3668:	347fad0a 	ldrbtcc	sl, [pc], #3338	; 3670 <CRM_GoToSleep+0x24>
./cpu/mc1322x/tools/rftestrx2pcap.pl:use Time::HiRes qw(usleep gettimeofday);
./cpu/mc1322x/tools/mc1322x-load.pl:use Time::HiRes qw(usleep);
./cpu/mc1322x/tools/mc1322x-load.pl:    print "       -a first  intercharacter delay, passed to usleep\n";
./cpu/mc1322x/tools/mc1322x-load.pl:    print "       -b second intercharacter delay, passed to usleep\n";
./cpu/mc1322x/tools/mc1322x-load.pl:                usleep($first_delay)  if ( $s == 0 ) && ($first_delay != 0);
./cpu/mc1322x/tools/mc1322x-load.pl:                usleep($second_delay) if ( $s == 1 ) && ($second_delay != 0);
./cpu/mc1322x/tools/ftditools/bbmc.c:	sleep(2);
./cpu/mc1322x/lib/include/crm.h:		uint32_t SLEEP_CNTL;
./cpu/mc1322x/lib/include/crm.h:		struct CRM_SLEEP_CNTL {
./cpu/mc1322x/lib/include/crm.h:		} SLEEP_CNTLbits;
./cpu/mc1322x/lib/include/crm.h:			uint32_t SLEEP_SYNC:1;
./cpu/mc1322x/lib/include/crm.h:static volatile uint32_t * const CRM_SLEEP_CNTL = ((volatile uint32_t *) (CRM_BASE+0x08));
./cpu/mc1322x/lib/include/crm.h:#define SLEEP_MODE_HIBERNATE bit(0)
./cpu/mc1322x/lib/include/crm.h:#define SLEEP_MODE_DOZE      bit(1)
./cpu/mc1322x/lib/include/crm.h:#define SLEEP_PAD_PWR     bit(7)
./cpu/mc1322x/lib/include/crm.h:#define SLEEP_RETAIN_MCU bit(6)
./cpu/mc1322x/lib/include/crm.h:#define sleep_ram_retain(x) (x<<4)   /* 0-3 */
./cpu/mc1322x/lib/include/crm.h:#define SLEEP_RAM_8K sleep_ram_retain(0)
./cpu/mc1322x/lib/include/crm.h:#define SLEEP_RAM_32K sleep_ram_retain(1)
./cpu/mc1322x/lib/include/crm.h:#define SLEEP_RAM_64K sleep_ram_retain(2)
./cpu/mc1322x/lib/include/crm.h:#define SLEEP_RAM_96K sleep_ram_retain(3)
./cpu/mc1322x/clock.c: * Adjust clock ticks after a cpu sleep.
./cpu/msp430/f5xxx/msp430.c:   sleep modes where the DCO clock stopped */
./cpu/msp430/dev/lpm.h:#define LPM_SLEEP() do { if(lpm_status == LPM_STATUS_ON) LPM_ON; } while(0)
./cpu/msp430/f1xxx/msp430.c:   sleep modes where the DCO clock stopped */
./cpu/stm32w108/Makefile.stm32w108:		stm32w-radio.c stm32w_systick.c uip_arch.c rtimer-arch.c adc.c micro.c sleep.c \
./cpu/stm32w108/hal/error-def.h: * @brief Sleeping (for a duration) has been abnormally interrupted
./cpu/stm32w108/hal/error-def.h:#define ST_SLEEP_INTERRUPTED(0x85)
./cpu/stm32w108/hal/error-def.h:DEFINE_ERROR(SLEEP_INTERRUPTED, 0x85)
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c: * \b NOTE:  The Sleep Timer count and compare registers are only 16 bits, but
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c: * the "action" register.  When working with SLEEPTMR_CNT, reading the "H"
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c: * be read.  When working with the SLEEPTMR_CMP registers, writing "L" will
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c://A simple flag used by internalSleepForQs to check that it has exited
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c://from sleep mode at the request of the expected timer interrupt.
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:static boolean sleepTimerInterruptOccurred = FALSE;
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:  time = SLEEPTMR_CNTH<<16;
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:  time |= SLEEPTMR_CNTL;
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:void halSleepTimerIsr(void)
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:  INT_SLEEPTMRFLAG = INT_SLEEPTMRWRAP | INT_SLEEPTMRCMPA | INT_SLEEPTMRCMPB;
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:  //mark a sleep timer interrupt as having occurred
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:  sleepTimerInterruptOccurred = TRUE;
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:static StStatus internalSleepForQs(boolean useGpioWakeMask,
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:  int32u sleepOverflowCount;
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:    INT_CFGCLR = INT_SLEEPTMR;
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:    //overflow of 4194304.0 seconds.  Calculate the number of sleep overflows
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:    sleepOverflowCount = (*duration)/TIMER_MAX_QS;
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:    //grab the starting sleep count
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:    sleepTimerInterruptOccurred = FALSE;
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      SLEEPTMR_CMPAL = (startCount+remainder)&0xFFFF;
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      SLEEPTMR_CMPAH = ((startCount+remainder)>>16)&0xFFFF;
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      INT_SLEEPTMRFLAG = INT_SLEEPTMRCMPA;
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      INT_SLEEPTMRCFG = INT_SLEEPTMRCMPA;
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:    if(sleepOverflowCount) {
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      SLEEPTMR_CMPBL = startCount&0xFFFF;
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      SLEEPTMR_CMPBH = (startCount>>16)&0xFFFF;
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      INT_SLEEPTMRFLAG = INT_SLEEPTMRCMPB;
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      INT_SLEEPTMRCFG = INT_SLEEPTMRCMPB;
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:    INT_CFGSET = INT_SLEEPTMR;
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      halSleepWithOptions(SLEEPMODE_WAKETIMER, gpioWakeBitMask);
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:    INT_SLEEPTMRCFG = INT_SLEEPTMRCFG_RESET; //disable all SleepTMR interrupts
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:    //If we didn't come out of sleep via a compare or overflow interrupt,
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:    //it was an abnormal sleep interruption; report the event.
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:    if(!sleepTimerInterruptOccurred) {
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      status = ST_SLEEP_INTERRUPTED;
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      //Update duration to account for how long last sleep was.  Using the
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      if(sleepOverflowCount) {
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:        sleepOverflowCount--;
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      sleepTimerInterruptOccurred = FALSE;
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      if(sleepOverflowCount) {
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:        //enable sleeping for a full timer wrap
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:        INT_SLEEPTMRFLAG = INT_SLEEPTMRCMPB;
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:        INT_SLEEPTMRCFG = INT_SLEEPTMRCMPB;
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:      } else if(!sleepOverflowCount && (*duration>0)){
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:        //enable sleeping for the remainder
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:        INT_SLEEPTMRFLAG = INT_SLEEPTMRCMPA;
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:        INT_SLEEPTMRCFG = INT_SLEEPTMRCMPA;
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:StStatus halSleepForQsWithOptions(int32u *duration, int32u gpioWakeBitMask)
./cpu/stm32w108/hal/micro/cortexm3/system-timer.c:  return internalSleepForQs(TRUE, duration, gpioWakeBitMask);
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h:  //This is necessary here because halSleepForQsWithOptions returns an
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h:/** @brief Puts the microcontroller to sleep in a specified mode, allows
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * @param sleepMode  A microcontroller sleep mode.
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * the chip from deep sleep.  A high bit in the mask will enable waking
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * @sa ::SleepModes
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h:void halSleepWithOptions(SleepModes sleepMode, int32u gpioWakeBitMask);
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * @brief Uses the system timer to enter ::SLEEPMODE_WAKETIMER for
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * decremented to 0 after sleeping for the specified amount of time.  If an
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * interrupt occurs that brings the chip out of sleep, the function returns
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * ::ST_SLEEP_INTERRUPTED and the duration parameter reports the amount of
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * @note The maximum sleep time of the hardware is limited on STM32W108 platforms
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * to 48.5 days.  Any sleep duration greater than this limit will wake up
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * briefly (e.g. 16 microseconds) to reenable another sleep cycle.
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * micro should be placed into ::SLEEPMODE_WAKETIMER.  When the function returns,
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * sleep time request (normally the return value will be 0).
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * the chip from deep sleep.  A high bit in the mask will enable waking
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h:StStatus halSleepForQsWithOptions(int32u *duration, int32u gpioWakeBitMask);
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * @brief Provides access to assembly code which triggers idle sleep.
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h:void halInternalIdleSleep(void);
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h:/** @brief Puts the microcontroller to sleep in a specified mode.  This
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: *  internal function performs the actual sleep operation.  This function
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * @param sleepMode  A microcontroller sleep mode
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h:void halInternalSleep(SleepModes sleepMode);
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * @brief Obtains the events that caused the last wake from sleep.  The
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * - [30] = SleepSkipped
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * - [26] = PWRUP_SLEEPTMRWRAP
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * - [25] = PWRUP_SLEEPTMRCOMPB
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * - [24] = PWRUP_SLEEPTMRCOMPA
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * WakeInfoValid means that ::halSleepWithOptions (::halInternalSleep) has been called
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * this bit says the sleep code has been called since power on.
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * SleepSkipped means that the chip never left the running state.  Sleep can
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * control from the CPU to the power management state machine.  Sleep can
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * signal is set).  The net affect of skipping sleep is the Low Voltage
./cpu/stm32w108/hal/micro/cortexm3/micro-common.h: * @return The events that caused the last wake from sleep. 
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/crt_stm32w108.c:void halSleepTimerIsr() __attribute__ ((weak, alias("Default_Handler")));
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/crt_stm32w108.c:  halSleepTimerIsr,          // 20
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/crt_stm32w108.c:  // reset type happens to be a deep sleep reset.  If the reset is not from
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/crt_stm32w108.c:  // deep sleep, then locals can be freely used
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/crt_stm32w108.c:  NVIC_IPR_7to4   = ((MED  <<NVIC_IPR_7to4_PRI_4_BIT) |      //Sleep Timer Handler
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/crt_stm32w108.c:  if((RESET_EVENT&RESET_DSLEEP) == RESET_DSLEEP) {
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/crt_stm32w108.c:    //of inside of the halInternalSleep code:
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/low_level_init.c:  // reset type happens to be a deep sleep reset.  If the reset is not from
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/low_level_init.c:  // deep sleep, then locals can be freely used
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/low_level_init.c:  NVIC_IPR_7to4   = ((MED  <<NVIC_IPR_7to4_PRI_4_BIT) |      //Sleep Timer Handler
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/low_level_init.c:  if((RESET_EVENT&RESET_DSLEEP) == RESET_DSLEEP) {
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/low_level_init.c:    //of inside of the halInternalSleep code:
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CLKEN                                       *((volatile int32u *)0x40000008u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CLKEN_REG                                   *((volatile int32u *)0x40000008u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CLKEN_ADDR                                  (0x40000008u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CLKEN_RESET                                 (0x00000002u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPTMR_CLK10KEN field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLK10KEN                            (0x00000002u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLK10KEN_MASK                       (0x00000002u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLK10KEN_BIT                        (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLK10KEN_BITS                       (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPTMR_CLK32KEN field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLK32KEN                            (0x00000001u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLK32KEN_MASK                       (0x00000001u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLK32KEN_BIT                        (0)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLK32KEN_BITS                       (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define REGEN_DSLEEP                                         *((volatile int32u *)0x40000014u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define REGEN_DSLEEP_REG                                     *((volatile int32u *)0x40000014u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define REGEN_DSLEEP_ADDR                                    (0x40000014u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define REGEN_DSLEEP_RESET                                   (0x00000001u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* REGEN_DSLEEP_FIELD field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define REGEN_DSLEEP_FIELD                           (0x00000001u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define REGEN_DSLEEP_FIELD_MASK                      (0x00000001u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define REGEN_DSLEEP_FIELD_BIT                       (0)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define REGEN_DSLEEP_FIELD_BITS                      (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* WAKE_SLEEPTMRWRAP field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define WAKE_SLEEPTMRWRAP                            (0x00000040u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define WAKE_SLEEPTMRWRAP_MASK                       (0x00000040u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define WAKE_SLEEPTMRWRAP_BIT                        (6)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define WAKE_SLEEPTMRWRAP_BITS                       (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* WAKE_SLEEPTMRCMPB field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define WAKE_SLEEPTMRCMPB                            (0x00000020u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define WAKE_SLEEPTMRCMPB_MASK                       (0x00000020u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define WAKE_SLEEPTMRCMPB_BIT                        (5)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define WAKE_SLEEPTMRCMPB_BITS                       (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* WAKE_SLEEPTMRCMPA field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define WAKE_SLEEPTMRCMPA                            (0x00000010u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define WAKE_SLEEPTMRCMPA_MASK                       (0x00000010u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define WAKE_SLEEPTMRCMPA_BIT                        (4)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define WAKE_SLEEPTMRCMPA_BITS                       (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* PWRUP_SLEEPTMRWRAP field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define PWRUP_SLEEPTMRWRAP                           (0x00000040u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define PWRUP_SLEEPTMRWRAP_MASK                      (0x00000040u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define PWRUP_SLEEPTMRWRAP_BIT                       (6)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define PWRUP_SLEEPTMRWRAP_BITS                      (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* PWRUP_SLEEPTMRCOMPB field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define PWRUP_SLEEPTMRCOMPB                          (0x00000020u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define PWRUP_SLEEPTMRCOMPB_MASK                     (0x00000020u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define PWRUP_SLEEPTMRCOMPB_BIT                      (5)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define PWRUP_SLEEPTMRCOMPB_BITS                     (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* PWRUP_SLEEPTMRCOMPA field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define PWRUP_SLEEPTMRCOMPA                          (0x00000010u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define PWRUP_SLEEPTMRCOMPA_MASK                     (0x00000010u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define PWRUP_SLEEPTMRCOMPA_BIT                      (4)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define PWRUP_SLEEPTMRCOMPA_BITS                     (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* RESET_DSLEEP field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define RESET_DSLEEP                                 (0x00000020u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define RESET_DSLEEP_MASK                            (0x00000020u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define RESET_DSLEEP_BIT                             (5)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define RESET_DSLEEP_BITS                            (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CFG                                         *((volatile int32u *)0x4000600Cu)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CFG_REG                                     *((volatile int32u *)0x4000600Cu)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CFG_ADDR                                    (0x4000600Cu)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CFG_RESET                                   (0x00000400u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPTMR_REVERSE field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_REVERSE                             (0x00001000u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_REVERSE_MASK                        (0x00001000u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_REVERSE_BIT                         (12)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_REVERSE_BITS                        (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPTMR_ENABLE field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_ENABLE                              (0x00000800u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_ENABLE_MASK                         (0x00000800u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_ENABLE_BIT                          (11)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_ENABLE_BITS                         (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPTMR_DBGPAUSE field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_DBGPAUSE                            (0x00000400u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_DBGPAUSE_MASK                       (0x00000400u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_DBGPAUSE_BIT                        (10)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_DBGPAUSE_BITS                       (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPTMR_CLKDIV field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLKDIV                              (0x000000F0u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLKDIV_MASK                         (0x000000F0u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLKDIV_BIT                          (4)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLKDIV_BITS                         (4)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPTMR_CLKSEL field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLKSEL                              (0x00000001u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLKSEL_MASK                         (0x00000001u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLKSEL_BIT                          (0)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CLKSEL_BITS                         (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CNTH                                        *((volatile int32u *)0x40006010u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CNTH_REG                                    *((volatile int32u *)0x40006010u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CNTH_ADDR                                   (0x40006010u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CNTH_RESET                                  (0x00000000u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPTMR_CNTH_FIELD field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CNTH_FIELD                          (0x0000FFFFu)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CNTH_FIELD_MASK                     (0x0000FFFFu)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CNTH_FIELD_BIT                      (0)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CNTH_FIELD_BITS                     (16)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CNTL                                        *((volatile int32u *)0x40006014u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CNTL_REG                                    *((volatile int32u *)0x40006014u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CNTL_ADDR                                   (0x40006014u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CNTL_RESET                                  (0x00000000u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPTMR_CNTL_FIELD field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CNTL_FIELD                          (0x0000FFFFu)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CNTL_FIELD_MASK                     (0x0000FFFFu)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CNTL_FIELD_BIT                      (0)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CNTL_FIELD_BITS                     (16)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPAH                                       *((volatile int32u *)0x40006018u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPAH_REG                                   *((volatile int32u *)0x40006018u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPAH_ADDR                                  (0x40006018u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPAH_RESET                                 (0x0000FFFFu)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPTMR_CMPAH_FIELD field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPAH_FIELD                         (0x0000FFFFu)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPAH_FIELD_MASK                    (0x0000FFFFu)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPAH_FIELD_BIT                     (0)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPAH_FIELD_BITS                    (16)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPAL                                       *((volatile int32u *)0x4000601Cu)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPAL_REG                                   *((volatile int32u *)0x4000601Cu)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPAL_ADDR                                  (0x4000601Cu)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPAL_RESET                                 (0x0000FFFFu)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPTMR_CMPAL_FIELD field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPAL_FIELD                         (0x0000FFFFu)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPAL_FIELD_MASK                    (0x0000FFFFu)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPAL_FIELD_BIT                     (0)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPAL_FIELD_BITS                    (16)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPBH                                       *((volatile int32u *)0x40006020u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPBH_REG                                   *((volatile int32u *)0x40006020u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPBH_ADDR                                  (0x40006020u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPBH_RESET                                 (0x0000FFFFu)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPTMR_CMPBH_FIELD field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPBH_FIELD                         (0x0000FFFFu)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPBH_FIELD_MASK                    (0x0000FFFFu)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPBH_FIELD_BIT                     (0)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPBH_FIELD_BITS                    (16)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPBL                                       *((volatile int32u *)0x40006024u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPBL_REG                                   *((volatile int32u *)0x40006024u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPBL_ADDR                                  (0x40006024u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define SLEEPTMR_CMPBL_RESET                                 (0x0000FFFFu)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPTMR_CMPBL_FIELD field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPBL_FIELD                         (0x0000FFFFu)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPBL_FIELD_MASK                    (0x0000FFFFu)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPBL_FIELD_BIT                     (0)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SLEEPTMR_CMPBL_FIELD_BITS                    (16)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define INT_SLEEPTMRFLAG                                     *((volatile int32u *)0x4000A014u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define INT_SLEEPTMRFLAG_REG                                 *((volatile int32u *)0x4000A014u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define INT_SLEEPTMRFLAG_ADDR                                (0x4000A014u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define INT_SLEEPTMRFLAG_RESET                               (0x00000000u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMRCMPB field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPB                             (0x00000004u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPB_MASK                        (0x00000004u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPB_BIT                         (2)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPB_BITS                        (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMRCMPA field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPA                             (0x00000002u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPA_MASK                        (0x00000002u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPA_BIT                         (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPA_BITS                        (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMRWRAP field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRWRAP                             (0x00000001u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRWRAP_MASK                        (0x00000001u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRWRAP_BIT                         (0)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRWRAP_BITS                        (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define INT_SLEEPTMRFORCE                                    *((volatile int32u *)0x4000A020u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define INT_SLEEPTMRFORCE_REG                                *((volatile int32u *)0x4000A020u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define INT_SLEEPTMRFORCE_ADDR                               (0x4000A020u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define INT_SLEEPTMRFORCE_RESET                              (0x00000000u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMRCMPB field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPB                             (0x00000004u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPB_MASK                        (0x00000004u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPB_BIT                         (2)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPB_BITS                        (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMRCMPA field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPA                             (0x00000002u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPA_MASK                        (0x00000002u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPA_BIT                         (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPA_BITS                        (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMRWRAP field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRWRAP                             (0x00000001u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRWRAP_MASK                        (0x00000001u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRWRAP_BIT                         (0)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRWRAP_BITS                        (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define INT_SLEEPTMRCFG                                      *((volatile int32u *)0x4000A054u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define INT_SLEEPTMRCFG_REG                                  *((volatile int32u *)0x4000A054u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define INT_SLEEPTMRCFG_ADDR                                 (0x4000A054u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define INT_SLEEPTMRCFG_RESET                                (0x00000000u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMRCMPB field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPB                             (0x00000004u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPB_MASK                        (0x00000004u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPB_BIT                         (2)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPB_BITS                        (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMRCMPA field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPA                             (0x00000002u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPA_MASK                        (0x00000002u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPA_BIT                         (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRCMPA_BITS                        (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMRWRAP field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRWRAP                             (0x00000001u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRWRAP_MASK                        (0x00000001u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRWRAP_BIT                         (0)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMRWRAP_BITS                        (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_MISSSLEEP field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_MISSSLEEP                                (0x00000010u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_MISSSLEEP_MASK                           (0x00000010u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_MISSSLEEP_BIT                            (4)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_MISSSLEEP_BITS                           (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPEVTENA field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define DWT_CTRL_SLEEPEVTENA                         (0x00080000u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define DWT_CTRL_SLEEPEVTENA_MASK                    (0x00080000u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define DWT_CTRL_SLEEPEVTENA_BIT                     (19)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define DWT_CTRL_SLEEPEVTENA_BITS                    (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define DWT_SLEEPCNT                                         *((volatile int32u *)0xE0001010u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define DWT_SLEEPCNT_REG                                     *((volatile int32u *)0xE0001010u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define DWT_SLEEPCNT_ADDR                                    (0xE0001010u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:#define DWT_SLEEPCNT_RESET                                   (0x00000000u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPCNT field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define DWT_SLEEPCNT_SLEEPCNT                        (0x000000FFu)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define DWT_SLEEPCNT_SLEEPCNT_MASK                   (0x000000FFu)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define DWT_SLEEPCNT_SLEEPCNT_BIT                    (0)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define DWT_SLEEPCNT_SLEEPCNT_BITS                   (8)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMR field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR                                 (0x00000010u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_MASK                            (0x00000010u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_BIT                             (4)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_BITS                            (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMR field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR                                 (0x00000010u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_MASK                            (0x00000010u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_BIT                             (4)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_BITS                            (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMR field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR                                 (0x00000010u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_MASK                            (0x00000010u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_BIT                             (4)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_BITS                            (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMR field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR                                 (0x00000010u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_MASK                            (0x00000010u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_BIT                             (4)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_BITS                            (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* INT_SLEEPTMR field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR                                 (0x00000010u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_MASK                            (0x00000010u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_BIT                             (4)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define INT_SLEEPTMR_BITS                            (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPDEEP field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SCS_SCR_SLEEPDEEP                            (0x00000004u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SCS_SCR_SLEEPDEEP_MASK                       (0x00000004u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SCS_SCR_SLEEPDEEP_BIT                        (2)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SCS_SCR_SLEEPDEEP_BITS                       (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* SLEEPONEXIT field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SCS_SCR_SLEEPONEXIT                          (0x00000002u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SCS_SCR_SLEEPONEXIT_MASK                     (0x00000002u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SCS_SCR_SLEEPONEXIT_BIT                      (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define SCS_SCR_SLEEPONEXIT_BITS                     (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        /* S_SLEEP field */
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define DEBUG_HCSR_S_SLEEP                           (0x00040000u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define DEBUG_HCSR_S_SLEEP_MASK                      (0x00040000u)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define DEBUG_HCSR_S_SLEEP_BIT                       (18)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.h:        #define DEBUG_HCSR_S_SLEEP_BITS                      (1)
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.ddf:sfr = "INT_MISS.INT_MISSSLEEP",                         "Memory",  0x4000A820,  4,        base=16,     bitMask=0x00000010
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.ddf:sfr = "INT_CFGSET.INT_SLEEPTMR",                        "Memory",  0xE000E100,  4,        base=16,     bitMask=0x00000010
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.ddf:sfr = "INT_CFGCLR.INT_SLEEPTMR",                        "Memory",  0xE000E180,  4,        base=16,     bitMask=0x00000010
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.ddf:sfr = "INT_PENDSET.INT_SLEEPTMR",                       "Memory",  0xE000E200,  4,        base=16,     bitMask=0x00000010
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.ddf:sfr = "INT_PENDCLR.INT_SLEEPTMR",                       "Memory",  0xE000E280,  4,        base=16,     bitMask=0x00000010
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/regs.ddf:sfr = "INT_ACTIVE.INT_SLEEPTMR",                        "Memory",  0xE000E300,  4,        base=16,     bitMask=0x00000010
./cpu/stm32w108/hal/micro/cortexm3/stm32w108/board.h: * @brief Perform board specific action to power down the system, usually before going to deep sleep.
./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:// @brief Context save/restore for deep sleep using the PendSV exception.
./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:// This file also contains a simple halInternalIdleSleep() function that
./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:// executes just the WFI instruction for idle sleeping.
./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:// When the STM32W108XX enters deep sleep, the hardware will actually remove power
./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:// from the Cortex-M3 core (in Deep Sleep 0, power is not removed but the core
./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:// must be properly restored such that execution can resume from the sleep code.
./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:// As its last act, the deep sleep code will trigger the PendSV exception to
./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:// perform a context save.  When the core is booted upon deep sleep exit, the
./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:// RESET_EVENT register informs cstartup if the chip just exited deep sleep.
./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:// was before deep sleep.
./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:// and trigger sleeping through the 'WFI' instruction, or restore a
./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:        WFI                   //all saved, trigger deep sleep
./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:        // powered off or reset (depending on the deep sleep level).
./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79://   void halInternalIdleSleep(void)
./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:// A simple internal function call (to be called from halSleep) for executing
./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:// the WFI instruction and entering the simple, idle sleep state.
./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:        __EXPORT__ halInternalIdleSleep
./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:halInternalIdleSleep:
./cpu/stm32w108/hal/micro/cortexm3/context-switch.s79:        WFI                    //trigger idle sleep
./cpu/stm32w108/hal/micro/cortexm3/cstartup_M.s:        DCD     halSleepTimerIsr     ;;Sleep Timer Handler
./cpu/stm32w108/hal/micro/cortexm3/cstartup_M.s:        PUBWEAK halSleepTimerIsr    
./cpu/stm32w108/hal/micro/cortexm3/cstartup_M.s:halSleepTimerIsr   
./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:  //Since the SleepTMR is the only timer maintained during deep sleep, it is
./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:  INT_CFGCLR = INT_SLEEPTMR;
./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:      SLEEPTMR_CLKEN = 0;
./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:      SLEEPTMR_CLKEN = SLEEPTMR_CLK32KEN;
./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:    //Sleep timer configuration is the same for crystal and external clock
./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:    SLEEPTMR_CFG = (SLEEPTMR_ENABLE            | //enable TMR
./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:                   (0 << SLEEPTMR_DBGPAUSE_BIT)| //TMR paused when halted
./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:                   (5 << SLEEPTMR_CLKDIV_BIT)  | //divide down to 1024Hz
./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:                   (1 << SLEEPTMR_CLKSEL_BIT)) ; //select XTAL
./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:    SLEEPTMR_CLKEN = SLEEPTMR_CLK10KEN;
./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:    SLEEPTMR_CFG = (SLEEPTMR_ENABLE            | //enable TMR
./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:                   (0 << SLEEPTMR_DBGPAUSE_BIT)| //TMR paused when halted
./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:                   (0 << SLEEPTMR_CLKDIV_BIT)  | //already 1024Hz
./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:                   (0 << SLEEPTMR_CLKSEL_BIT)) ; //select SlowRC
./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:  INT_SLEEPTMRFLAG = (INT_SLEEPTMRWRAP | INT_SLEEPTMRCMPA | INT_SLEEPTMRCMPB);
./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:  INT_SLEEPTMRCFG = INT_SLEEPTMRCFG_RESET;
./cpu/stm32w108/hal/micro/cortexm3/micro-common.c:  INT_CFGSET = INT_SLEEPTMR;
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:/** @file hal/micro/cortexm3/sleep.c
./cpu/stm32w108/hal/micro/cortexm3/sleep.c: * @brief STM32W108 micro specific sleep functions.
./cpu/stm32w108/hal/micro/cortexm3/sleep.c://This "register" is only ever set by halInternalSleep.
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:// [30] = SleepSkipped
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:#define SLEEPSKIPPED_INTERNAL_WAKE_EVENT_BIT  30
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:void halInternalSleep(SleepModes sleepMode)
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:  //the state here in case SLEEPMODE_NOTIMER is invoked, which would disable
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:  int32u SLEEPTMR_CLKEN_SAVED = SLEEPTMR_CLKEN;
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:  //As such, it should be called from halSleepWithOptions() or from
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:  // halSleepForQsWithOptions() which configues the wake sources.
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:  switch(sleepMode)
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:    case SLEEPMODE_NOTIMER:
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      //The sleep timer clock sources (both RC and XTAL) are turned off.
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      SLEEPTMR_CLKEN = 0;
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      goto deepSleepCore;
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:    case SLEEPMODE_WAKETIMER:
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      //The sleep timer clock sources remain running.  The RC is always
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      //is possible from both GPIO and the sleep timer.  System time
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      //is maintained.  The sleep timer is assumed to be configured
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      //      sleep timer properly.
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      if(INT_SLEEPTMRCFG&INT_SLEEPTMRWRAP) {
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        WAKE_SEL |= WAKE_SLEEPTMRWRAP;
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      if(INT_SLEEPTMRCFG&INT_SLEEPTMRCMPB) {
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        WAKE_SEL |= WAKE_SLEEPTMRCMPB;
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      if(INT_SLEEPTMRCFG&INT_SLEEPTMRCMPA) {
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        WAKE_SEL |= WAKE_SLEEPTMRCMPA;
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      //fall into SLEEPMODE_MAINTAINTIMER's sleep code:
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:    case SLEEPMODE_MAINTAINTIMER:
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      //The sleep timer clock sources remain running.  The RC is always
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      //NOTE: System time is maintained without any sleep timer interrupts
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      //      because the hardware sleep timer counter is large enough
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:    // Core deep sleep code
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:deepSleepCore:
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      // Interrupts *must* be/stay disabled for DEEP SLEEP operation
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      // deep sleep.
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        boolean skipSleep = FALSE;
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        // Only three register blocks keep power across deep sleep:
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        // All other register blocks lose their state across deep sleep:
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        // The sleep code will only save and restore registers where it is
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        int32u INT_SLEEPTMRCFG_SAVED = INT_SLEEPTMRCFG_REG;
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //ST_CSR - fixed, restored by cstartup when exiting deep sleep
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //ST_RVR - fixed, restored by cstartup when exiting deep sleep
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //NVIC_IPR_3to0 - fixed, restored by cstartup when exiting deep sleep
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //NVIC_IPR_7to4 - fixed, restored by cstartup when exiting deep sleep
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //NVIC_IPR_11to8 - fixed, restored by cstartup when exiting deep sleep
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //NVIC_IPR_15to12 - fixed, restored by cstartup when exiting deep sleep
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //NVIC_IPR_19to16 - fixed, restored by cstartup when exiting deep sleep
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //SCS_CCR - fixed, restored by cstartup when exiting deep sleep
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //SCS_SHPR_7to4 - fixed, restored by cstartup when exiting deep sleep
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //SCS_SHPR_11to8 - fixed, restored by cstartup when exiting deep sleep
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //SCS_SHPR_15to12 - fixed, restored by cstartup when exiting deep sleep
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //SCS_SHCSR - fixed, restored by cstartup when exiting deep sleep
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //sometime while entering sleep, so we need to skip over sleeping
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //  SleepTMR CMPA, CMPB, Wrap
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          skipSleep = TRUE;
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          skipSleep = TRUE;
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          skipSleep = TRUE;
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          skipSleep = TRUE;
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //check for SleepTMR CMPA interrupt and if SleepTMR CMPA is wake source
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        if((INT_SLEEPTMR&INT_SLEEPTMRCMPA) && (WAKE_SEL&WAKE_SLEEPTMRCMPA)) {
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          skipSleep = TRUE;
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          //log SleepTMR CMPA as a wake event
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //check for SleepTMR CMPB interrupt and if SleepTMR CMPB is wake source
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        if((INT_SLEEPTMR&INT_SLEEPTMRCMPB) && (WAKE_SEL&WAKE_SLEEPTMRCMPB)) {
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          skipSleep = TRUE;
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          //log SleepTMR CMPB as a wake event
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //check for SleepTMR WRAP interrupt and if SleepTMR WRAP is wake source
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        if((INT_SLEEPTMR&INT_SLEEPTMRWRAP) && (WAKE_SEL&WAKE_SLEEPTMRWRAP)) {
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          skipSleep = TRUE;
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          //log SleepTMR WRAP as a wake event
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          skipSleep = TRUE;
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //only propagate across deep sleep the interrupts that are both
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          if( (WAKE_SEL&WAKE_SLEEPTMRCMPA) ||
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:              (WAKE_SEL&WAKE_SLEEPTMRCMPB) ||
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:              (WAKE_SEL&WAKE_SLEEPTMRWRAP) ) {
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:            wakeSourceInterruptMask |= INT_SLEEPTMR;
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //disable watchdog while sleeping (since we can't reset it asleep)
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //The chip is not allowed to enter a deep sleep mode (which could
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //chip that would get reset during deep sleep.  Therefore, a reset
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //connected).  But, we cannot induce deep sleep until CSYSPWRUPREQ/ACK
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //we can proceed into deep sleep.  The CSYSPWRUPACK_INHIBIT
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //until we are safely past and out of deep sleep.  The power management
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          //if there was a wake event, allow CSYSPWRUPACK and skip sleep
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:            skipSleep = TRUE;
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        if(!skipSleep) {
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          //deep sleep since using the 24MHz XTAL could result in RAM
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          //sleeping.
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          //FogBugz 8858 states that we cannot go into deep-sleep when the
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          //REGEN_DSLEEP here.  This is hugely dangerous and
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          SCS_SCR |= SCS_SCR_SLEEPDEEP;      //enable deep sleep
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          SCS_ICSR |= SCS_ICSR_PENDSVSET;    //pend the context save and Dsleep
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          //I AM ASLEEP.  WHEN EXECUTION RESUMES, CSTARTUP WILL RESTORE TO HERE
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          //Record the fact that we skipped sleep
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          halInternalWakeEvent |= BIT32(SLEEPSKIPPED_INTERNAL_WAKE_EVENT_BIT);
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          //If this was a true deep sleep, we would have executed cstartup and
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          //PRIMASK would be set right now.  If we skipped sleep, PRIMASK is not
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //is necessary because if we don't execute an actual deep sleep cycle
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //we always mimick a real deep sleep as closely as possible and
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //of deep sleep.  (The interrupt dispatch code coming out of sleep
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        INT_SLEEPTMRFLAG = (INT_SLEEPTMRCMPA |
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:                            INT_SLEEPTMRCMPB |
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:                            INT_SLEEPTMRWRAP);
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //immediately restore the registers we saved before sleeping
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //so IRQ and SleepTMR capture can be reenabled as quickly as possible
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        SLEEPTMR_CLKEN_REG = SLEEPTMR_CLKEN_SAVED;
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        INT_SLEEPTMRCFG_REG = INT_SLEEPTMRCFG_SAVED;
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:                                   PWRUP_SLEEPTMRWRAP_MASK  |
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:                                   PWRUP_SLEEPTMRCOMPB_MASK |
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:                                   PWRUP_SLEEPTMRCOMPA_MASK ))
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //restart watchdog if it was running when we entered sleep
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //Pend any interrupts associated with deep sleep wake sources.  The
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //halSleepWithOptions.
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //The SleepTMR CMPA is linked to a real ISR.  If the SleepTMR CMPA
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        if( (INT_SLEEPTMRCFG&INT_SLEEPTMRCMPA) &&
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          INT_SLEEPTMRFORCE = INT_SLEEPTMRCMPA;
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //The SleepTMR CMPB is linked to a real ISR.  If the SleepTMR CMPB
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        if( (INT_SLEEPTMRCFG&INT_SLEEPTMRCMPB) &&
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          INT_SLEEPTMRFORCE = INT_SLEEPTMRCMPB;
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //The SleepTMR WRAP is linked to a real ISR.  If the SleepTMR WRAP
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        if( (INT_SLEEPTMRCFG&INT_SLEEPTMRWRAP) &&
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:          INT_SLEEPTMRFORCE = INT_SLEEPTMRWRAP;
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      break; //and deep sleeping is done!
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:    case SLEEPMODE_IDLE:
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //disable watchdog while sleeping (since we can't reset it asleep)
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        halInternalIdleSleep();
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:        //restart watchdog if it was running when we entered sleep
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:      //Oops!  Invalid sleepMode parameter.
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:void halSleepWithOptions(SleepModes sleepMode, int32u gpioWakeBitMask)
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:  //wake sources are configured so do the actual sleeping
./cpu/stm32w108/hal/micro/cortexm3/sleep.c:  halInternalSleep(sleepMode);
./cpu/stm32w108/hal/micro/micro-common.h:  //This is necessary here because halSleepForQsWithOptions returns an
./cpu/stm32w108/hal/micro/micro-common.h:/** @brief Enumerations for the possible microcontroller sleep modes.
./cpu/stm32w108/hal/micro/micro-common.h: * - SLEEPMODE_RUNNING
./cpu/stm32w108/hal/micro/micro-common.h: * - SLEEPMODE_IDLE
./cpu/stm32w108/hal/micro/micro-common.h: * - SLEEPMODE_WAKETIMER
./cpu/stm32w108/hal/micro/micro-common.h: *     The sleep timer clock sources remain running.  The RC is always
./cpu/stm32w108/hal/micro/micro-common.h: *     is possible from both GPIO and the sleep timer.  System time
./cpu/stm32w108/hal/micro/micro-common.h: *     is maintained.  The sleep timer is assumed to be configured
./cpu/stm32w108/hal/micro/micro-common.h: * - SLEEPMODE_MAINTAINTIMER
./cpu/stm32w108/hal/micro/micro-common.h: *     The sleep timer clock sources remain running.  The RC is always
./cpu/stm32w108/hal/micro/micro-common.h: * - SLEEPMODE_NOTIMER
./cpu/stm32w108/hal/micro/micro-common.h: *     The sleep timer clock sources (both RC and XTAL) are turned off.
./cpu/stm32w108/hal/micro/micro-common.h:enum SleepModes
./cpu/stm32w108/hal/micro/micro-common.h:typedef int8u SleepModes;
./cpu/stm32w108/hal/micro/micro-common.h:  SLEEPMODE_RUNNING = 0,
./cpu/stm32w108/hal/micro/micro-common.h:  SLEEPMODE_IDLE = 1,
./cpu/stm32w108/hal/micro/micro-common.h:  SLEEPMODE_WAKETIMER = 2,
./cpu/stm32w108/hal/micro/micro-common.h:  SLEEPMODE_MAINTAINTIMER = 3,
./cpu/stm32w108/hal/micro/micro-common.h:  SLEEPMODE_NOTIMER = 4,
./cpu/stm32w108/dev/stm32w-radio.c:                                  ST_RadioSleep();                    \
./cpu/stm32w108/dev/stm32w-radio.c:    /* Put CPU in sleep mode. */
./cpu/stm32w108/dev/stm32w-radio.c:    halSleepWithOptions(SLEEPMODE_IDLE,0);
./cpu/stm32w108/dev/stm32w-radio.c:    ST_RadioSleep();
./cpu/stm32w108/sleep.h:/* Enter system in deep sleep 1 (core power domain is fully
./cpu/stm32w108/sleep.h: * powered down and sleep timer is active).
./cpu/stm32w108/sleep.h:void sleep_seconds(int seconds);
Binary file ./cpu/stm32w108/simplemac/library/simplemac-library-gnu.a matches
Binary file ./cpu/stm32w108/simplemac/library/simplemac-library.a matches
./cpu/stm32w108/simplemac/include/phy-library.h: * This function must be called once after chip reset or wake from deep sleep.
./cpu/stm32w108/simplemac/include/phy-library.h: * sleep.
./cpu/stm32w108/simplemac/include/phy-library.h: * ST_RadioSleep().
./cpu/stm32w108/simplemac/include/phy-library.h:void ST_RadioSleep(void);
./cpu/stm32w108/simplemac/include/phy-library.h: * If the radio is asleep this function will wake it to perform channel
./cpu/stm32w108/simplemac/include/phy-library.h: * calibration and then return it to sleep before exiting.
./cpu/stm32w108/board-sensors.h: * Useful when entering in sleep mode, since all system
./cpu/stm32w108/board-sensors.h: * in deep sleep mode.
./cpu/stm32w108/clock.c:sleep_seconds(int seconds)
./cpu/stm32w108/clock.c:  halSleepForQsWithOptions(&quarter_seconds, 0);
./cpu/cc253x/sfr-bits.h:/* SLEEPCMD and SLEEPSTA */
./cpu/cc253x/sfr-bits.h:#define SLEEP_OSC32K_CALDIS  0x80
./cpu/cc253x/sfr-bits.h:#define SLEEP_XOSC_STB       0x40
./cpu/cc253x/sfr-bits.h:#define SLEEP_HFRC_STB       0x20
./cpu/cc253x/sfr-bits.h:#define SLEEP_RST1           0x10 /* SLEEPSTA only */
./cpu/cc253x/sfr-bits.h:#define SLEEP_RST0           0x08 /* SLEEPSTA only */
./cpu/cc253x/sfr-bits.h:#define SLEEP_OSC_PD         0x04
./cpu/cc253x/sfr-bits.h:#define SLEEP_MODE1          0x02
./cpu/cc253x/sfr-bits.h:#define SLEEP_MODE0          0x01
./cpu/cc253x/dev/dma.h:#define DMA_T_ST        11 /* Sleep Timer compare */
./cpu/cc253x/dev/clock-isr.h: *         Declaration of the Sleep timer ISR, used by the clock module
./cpu/cc253x/dev/clock.c:/* Sleep timer runs on the 32k RC osc. */
./cpu/cc253x/dev/clock.c:volatile __bit sleep_flag;
./cpu/cc253x/dev/clock.c: * TI examples appear to be writing to SLEEPCMD, initialising hardware in a
./cpu/cc253x/dev/clock.c: * However, the datasheet claims that those bits in SLEEPCMD are reserved
./cpu/cc253x/dev/clock.c:  sleep_flag = 1;
./cpu/cc253x/cc253x.h:#define ST_VECTOR        5  /* Sleep Timer compare */
./cpu/cc253x/cc253x.h:  SBIT(STIE,     0xA8, 5); /* Sleep Timer interrupt enable */
./cpu/cc253x/cc253x.h:  SBIT(STIF,     0xC0, 7); /* Sleep Timer interrupt flag */
./cpu/cc253x/cc253x.h:/* Sleep Timer */
./cpu/cc253x/cc253x.h:SFR(ST0,       0x95); /* Sleep Timer 0 */
./cpu/cc253x/cc253x.h:SFR(ST1,       0x96); /* Sleep Timer 1 */
./cpu/cc253x/cc253x.h:SFR(ST2,       0x97); /* Sleep Timer 2 */
./cpu/cc253x/cc253x.h:SFR(STLOAD,    0xAD); /* Sleep-timer load status */
./cpu/cc253x/cc253x.h:SFR(SLEEPCMD,  0xBE); /* Sleep-mode control command */
./cpu/cc253x/cc253x.h:SFR(SLEEPSTA,  0x9D); /* Sleep-mode control status */
./cpu/cc253x/cc253x.h:SFRX(SRCRC,      0x6262); /* Sleep reset CRC */
./cpu/cc253x/cc253x.h:SFRX(STCC,       0x62B0); /* Sleep Timer capture control */
./cpu/cc253x/cc253x.h:SFRX(STCS,       0x62B1); /* Sleep Timer capture status */
./cpu/cc253x/cc253x.h:SFRX(STCV0,      0x62B2); /* Sleep Timer capture value byte 0 */
./cpu/cc253x/cc253x.h:SFRX(STCV1,      0x62B3); /* Sleep Timer capture value byte 1 */
./cpu/cc253x/cc253x.h:SFRX(STCV2,      0x62B4); /* Sleep Timer capture value byte 2 */
./cpu/cc253x/cc253x.h:SFRX(X_ST0,       0x7095); /* Sleep Timer 0 */
./cpu/cc253x/cc253x.h:SFRX(X_ST1,       0x7096); /* Sleep Timer 1 */
./cpu/cc253x/cc253x.h:SFRX(X_ST2,       0x7097); /* Sleep Timer 2 */
./cpu/cc253x/cc253x.h:SFRX(X_SLEEPSTA,  0x709D); /* Sleep-mode control status */
./cpu/cc253x/cc253x.h:SFRX(X_STLOAD,    0x70AD); /* Sleep-timer load status */
./cpu/cc253x/cc253x.h:SFRX(X_SLEEPCMD,  0x70BE); /* Sleep-mode control command */
./cpu/arm/at91sam7s/AT91SAM7S256.h:#define AT91C_ADC_SLEEP       (0x1 <<  5) // (ADC) Sleep Mode
./cpu/arm/at91sam7s/AT91SAM7S256.h:#define 	AT91C_ADC_SLEEP_NORMAL_MODE          (0x0 <<  5) // (ADC) Normal Mode
./cpu/arm/at91sam7s/AT91SAM7S256.h:#define 	AT91C_ADC_SLEEP_MODE                 (0x1 <<  5) // (ADC) Sleep Mode
./cpu/arm/at91sam7s/AT91SAM7S128.h:#define AT91C_ADC_SLEEP       (0x1 <<  5) // (ADC) Sleep Mode
./cpu/arm/at91sam7s/AT91SAM7S128.h:#define 	AT91C_ADC_SLEEP_NORMAL_MODE          (0x0 <<  5) // (ADC) Normal Mode
./cpu/arm/at91sam7s/AT91SAM7S128.h:#define 	AT91C_ADC_SLEEP_MODE                 (0x1 <<  5) // (ADC) Sleep Mode
./cpu/arm/at91sam7s/AT91SAM7S64.h:#define AT91C_ADC_SLEEP       (0x1 <<  5) // (ADC) Sleep Mode
./cpu/arm/at91sam7s/AT91SAM7S64.h:#define 	AT91C_ADC_SLEEP_NORMAL_MODE          (0x0 <<  5) // (ADC) Normal Mode
./cpu/arm/at91sam7s/AT91SAM7S64.h:#define 	AT91C_ADC_SLEEP_MODE                 (0x1 <<  5) // (ADC) Sleep Mode
./cpu/arm/at91sam7s/Makefile.at91sam7s:	$(OPENOCD) -s $(OPENOCD_DIR) -f $(OPENOCD_CFG) -c init -c "halt;mww 0xffffff64 0x5a000004;sleep 250;mww 0xffffff64 0x5a002004; sleep 250;flash probe 0;flash write_bank 0 $< 0x0;reset run;sleep 500;exit"
./cpu/arm/at91sam7s/openocd/openocd_reset:sleep 500
./cpu/arm/at91sam7s/openocd/openocd_flash:sleep 250
./cpu/arm/at91sam7s/openocd/openocd_flash:sleep 250
./cpu/arm/at91sam7s/openocd/openocd_flash:sleep 500
./cpu/arm/stm32f103/stm32f10x_map.h:#define  PWR_CR_LPDS                         ((u16)0x0001)     /* Low-Power Deepsleep */
./cpu/arm/stm32f103/stm32f10x_map.h:#define  PWR_CR_PDDS                         ((u16)0x0002)     /* Power Down Deepsleep */
./cpu/arm/stm32f103/stm32f10x_map.h:#define  SCB_SCR_SLEEPONEXIT                 ((u8)0x02)               /* Sleep on exit bit */
./cpu/arm/stm32f103/stm32f10x_map.h:#define  SCB_SCR_SLEEPDEEP                   ((u8)0x04)               /* Sleep deep bit */
./cpu/arm/stm32f103/stm32f10x_map.h:#define  CAN_MCR_SLEEP                       ((u16)0x0002)            /* Sleep Mode Request */
./cpu/arm/stm32f103/stm32f10x_map.h:#define  CAN_MSR_SLAK                        ((u16)0x0002)            /* Sleep Acknowledge */
./cpu/arm/stm32f103/stm32f10x_map.h:#define  CAN_MSR_SLAKI                       ((u16)0x0010)            /* Sleep Acknowledge Interrupt */
./cpu/arm/stm32f103/stm32f10x_map.h:#define  CAN_IER_SLKIE                       ((u32)0x00020000)        /* Sleep Interrupt Enable */
./cpu/arm/stm32f103/stm32f10x_map.h:#define  DBGMCU_CR_DBG_SLEEP                 ((u32)0x00000001)        /* Debug Sleep Mode */
./cpu/arm/stm32f103/stm32f10x_nvic.h:#define NVIC_LP_SLEEPDEEP            ((u8)0x04)
./cpu/arm/stm32f103/stm32f10x_nvic.h:#define NVIC_LP_SLEEPONEXIT          ((u8)0x02)
./cpu/arm/stm32f103/stm32f10x_nvic.h:                        ((LP) == NVIC_LP_SLEEPDEEP) || \
./cpu/arm/stm32f103/stm32f10x_nvic.h:                        ((LP) == NVIC_LP_SLEEPONEXIT))
./cpu/arm/stm32f103/Makefile.stm32f103:	$(OPENOCD) -s $(OPENOCD_DIR) -f $(OPENOCD_CFG) -c init -c "reset halt;sleep 250;flash probe 0;stm32x mass_erase 0; sleep 500;flash write_bank 0 $< 0;reset halt;resume;sleep 500;exit"
./doc/sicslowmac-doc.txt:formation. Additionally, routing and low power/sleep will be implemented in
./tools/sky/msp430-bsl-linux:            time.sleep(0.040)
./tools/sky/msp430-bsl-linux:            time.sleep(0.040)
./tools/sky/msp430-bsl-linux:        time.sleep(2e-6)
./tools/sky/msp430-bsl-linux:        time.sleep(1e-6)
./tools/sky/msp430-bsl-linux:        time.sleep(0.250)       #give MSP430's oscillator time to stabilize
./tools/sky/msp430-bsl-linux:        time.sleep(0.250)       #charge capacitor on boot loader hardware
./tools/sky/msp430-bsl-linux:        time.sleep(0.250)       #give MSP430's oscillator time to stabilize
./tools/sky/msp430-bsl-linux:        time.sleep(0.010)                   #recomended delay
Binary file ./tools/sky/msp430-bsl-windows.exe matches
Binary file ./tools/sky/python23.dll matches
Binary file ./tools/sky/serialdump-linux matches
./tools/sky/serial/serialwin32.py:        time.sleep(0.020)
Binary file ./tools/sky/serialdump-windows.exe matches
Binary file ./tools/sky/lib/shared-bsl.zip matches
./tools/sky/serialdump.c:	      usleep(6000);
./tools/cooja/apps/native_gateway/java/se/sics/cooja/plugins/NativeIPGateway.java:      Thread.sleep(250);
Binary file ./tools/cooja/apps/avrora/lib/avrora-small.jar matches
Binary file ./tools/cooja/build/se/sics/cooja/plugins/LogScriptEngine$9$2.class matches
Binary file ./tools/cooja/build/se/sics/cooja/plugins/LogScriptEngine$9$1.class matches
Binary file ./tools/cooja/build/se/sics/cooja/Simulation$2.class matches
./tools/cooja/java/se/sics/cooja/plugins/LogScriptEngine.java:          try { Thread.sleep(500); } catch (InterruptedException e) { }
./tools/cooja/java/se/sics/cooja/plugins/LogScriptEngine.java:          try { Thread.sleep(2000); } catch (InterruptedException e) { }
./tools/cooja/java/se/sics/cooja/radiomediums/AbstractRadioMedium.java:   * This method can be called if a radio node falls asleep or is removed.
./tools/cooja/java/se/sics/cooja/Simulation.java:      long sleep = expectedDiffRealtime - diffRealtime;
./tools/cooja/java/se/sics/cooja/Simulation.java:      if (sleep >= 0) {
./tools/cooja/java/se/sics/cooja/Simulation.java:          Thread.sleep(sleep);
./tools/cooja/java/se/sics/cooja/Simulation.java:        scheduleEvent(this, t-sleep*MILLISECOND);
./tools/z1/z1-bsl:            time.sleep(0.040)
./tools/z1/z1-bsl:            time.sleep(0.040)
./tools/z1/z1-bsl:        #time.sleep(0.1)
./tools/z1/z1-bsl:        #time.sleep(0.1)
./tools/z1/z1-bsl:        #time.sleep(0.02)
./tools/z1/z1-bsl:            time.sleep(0.02)
./tools/z1/z1-bsl:        time.sleep(0.02)
./tools/z1/z1-bsl:            time.sleep(0.1)
./tools/z1/z1-bsl:            time.sleep(0.1)
./tools/z1/z1-bsl:            time.sleep(0.1)
./tools/z1/z1-bsl:            time.sleep(0.1)
./tools/z1/z1-bsl:        time.sleep(2e-6)
./tools/z1/z1-bsl:        time.sleep(1e-6)
./tools/z1/z1-bsl:          time.sleep(0.250)       #give MSP430's oscillator time to stabilize
./tools/z1/z1-bsl:        time.sleep(0.250)       #charge capacitor on boot loader hardware
./tools/z1/z1-bsl:        time.sleep(0.250)       #give MSP430's oscillator time to stabilize
./tools/z1/z1-bsl:        time.sleep(0.010)                   #recomended delay
./tools/z1/z1-bsl-nopic:            time.sleep(0.040)
./tools/z1/z1-bsl-nopic:            time.sleep(0.040)
./tools/z1/z1-bsl-nopic:        #time.sleep(0.1)
./tools/z1/z1-bsl-nopic:        #time.sleep(0.1)
./tools/z1/z1-bsl-nopic:        #time.sleep(0.02)
./tools/z1/z1-bsl-nopic:            time.sleep(0.02)
./tools/z1/z1-bsl-nopic:        time.sleep(0.02)
./tools/z1/z1-bsl-nopic:            time.sleep(0.1)
./tools/z1/z1-bsl-nopic:            time.sleep(0.1)
./tools/z1/z1-bsl-nopic:            time.sleep(0.1)
./tools/z1/z1-bsl-nopic:            time.sleep(0.1)
./tools/z1/z1-bsl-nopic:        time.sleep(2e-6)
./tools/z1/z1-bsl-nopic:        time.sleep(1e-6)
./tools/z1/z1-bsl-nopic:          time.sleep(0.250)       #give MSP430's oscillator time to stabilize
./tools/z1/z1-bsl-nopic:        time.sleep(0.250)       #charge capacitor on boot loader hardware
./tools/z1/z1-bsl-nopic:        time.sleep(0.250)       #give MSP430's oscillator time to stabilize
./tools/z1/z1-bsl-nopic:        time.sleep(0.010)                   #recomended delay
Binary file ./tools/collect-view/build/se/sics/contiki/collect/CollectServer.class matches
Binary file ./tools/collect-view/build/se/sics/contiki/collect/gui/NodeControl$2.class matches
Binary file ./tools/collect-view/build/se/sics/contiki/collect/MoteProgrammerProcess$1.class matches
Binary file ./tools/collect-view/build/se/sics/contiki/collect/CollectServer$MoteProgramAction.class matches
Binary file ./tools/collect-view/build/se/sics/contiki/collect/StdinConnection$1.class matches
Binary file ./tools/collect-view/build/se/sics/contiki/collect/CollectServer$37.class matches
./tools/collect-view/src/se/sics/contiki/collect/gui/NodeControl.java:                Thread.sleep(1000);
./tools/collect-view/src/se/sics/contiki/collect/MoteProgrammerProcess.java:              Thread.sleep(2000);
./tools/collect-view/src/se/sics/contiki/collect/StdinConnection.java:                Thread.sleep(100);
./tools/collect-view/src/se/sics/contiki/collect/CollectServer.java:  private void sleep(long delay) {
./tools/collect-view/src/se/sics/contiki/collect/CollectServer.java:      Thread.sleep(delay);
./tools/collect-view/src/se/sics/contiki/collect/CollectServer.java:            } else if (line.startsWith("sleep ")) {
./tools/collect-view/src/se/sics/contiki/collect/CollectServer.java:              Thread.sleep(delay * 1000);
./tools/collect-view/src/se/sics/contiki/collect/CollectServer.java:            Thread.sleep(1000);
./tools/collect-view/src/se/sics/contiki/collect/CollectServer.java:        sleep(3000);
Binary file ./tools/collect-view/dist/tools/cygwin1.dll matches
./tools/collect-view/dist/tools/msp430-bsl-linux:            time.sleep(0.040)
./tools/collect-view/dist/tools/msp430-bsl-linux:            time.sleep(0.040)
./tools/collect-view/dist/tools/msp430-bsl-linux:        time.sleep(2e-6)
./tools/collect-view/dist/tools/msp430-bsl-linux:        time.sleep(1e-6)
./tools/collect-view/dist/tools/msp430-bsl-linux:        time.sleep(0.250)       #give MSP430's oscillator time to stabilize
./tools/collect-view/dist/tools/msp430-bsl-linux:        time.sleep(0.250)       #charge capacitor on boot loader hardware
./tools/collect-view/dist/tools/msp430-bsl-linux:        time.sleep(0.250)       #give MSP430's oscillator time to stabilize
./tools/collect-view/dist/tools/msp430-bsl-linux:        time.sleep(0.010)                   #recomended delay
Binary file ./tools/collect-view/dist/tools/msp430-bsl-windows.exe matches
Binary file ./tools/collect-view/dist/tools/python23.dll matches
Binary file ./tools/collect-view/dist/tools/serialdump-linux matches
./tools/collect-view/dist/tools/serial/serialwin32.py:        time.sleep(0.020)
Binary file ./tools/collect-view/dist/tools/serialdump-windows.exe matches
Binary file ./tools/collect-view/dist/tools/lib/shared-bsl.zip matches
./tools/collect-view/dist/tools/serialdump.c:	      usleep(6000);
./tools/collect-view/dist/collect-init.script:sleep 2
./tools/collect-view/dist/collect-init.script:sleep 2
./tools/collect-view/collect-init.script:sleep 2
./tools/collect-view/collect-init.script:sleep 2
./tools/sensinode/nano_usb_programmer/prog.c: *	This function checks if the CBUS2 ise set to SLEEP and modifies it if necessary.
./tools/sensinode/nano_usb_programmer/prog.c: *	The CBUS2 must be set to sleep in order the programming to succeed.
./tools/sensinode/nano_usb_programmer/prog.c:		sleep(3);
./tools/sensinode/nano_usb_programmer/prog.c:		sleep(1);
./tools/sensinode/nano_usb_programmer/prog.c:		sleep(1);
./tools/sensinode/nano_usb_programmer/ihex.c:			usleep(3000);
./tools/sensinode/nano_usb_programmer/ihex.c:			usleep(20000);
./tools/sensinode/nano_usb_programmer/cdi.c:#define pause_ms(x) usleep(x*1000)
./tools/sensinode/nano_usb_programmer/cdi.c:#define pause_us(x) usleep(x)
./tools/sensinode/nano_programmer/programmer.c:		usleep(5000);
./tools/sensinode/nano_programmer/programmer.c:				sleep(1);
./tools/sensinode/nano_programmer/programmer.c:				sleep(1);
./tools/sensinode/nano_programmer/programmer.c:				usleep(300000);
./tools/sensinode/nano_programmer/programmer.c:				usleep(200000);
./tools/sensinode/nano_programmer/programmer.c:				usleep(100000);
./tools/sensinode/nano_programmer/programmer.c:		sleep(1);
./tools/sensinode/nano_programmer/linux/port.c:			else	usleep(1000);
./tools/sensinode/nano_programmer/linux/port.c:			else	usleep(1000);
./tools/sensinode/nano_programmer/linux/port.c:		usleep(1250);
./tools/sensinode/nano_programmer/cdi_program.c:		sleep(1);
./tools/sensinode/nano_programmer/cdi_program.c:	usleep(100000);
./tools/sensinode/nano_programmer/cdi_program.c:				usleep(3000);
./tools/sensinode/nano_programmer/cdi_program.c:							usleep(20000);
./tools/sensinode/nano_programmer/cdi_program.c:						usleep(20000);
./tools/sensinode/nano_programmer/cdi_program.c:		usleep(200000);
./tools/sensinode/nano_programmer/cdi_program.c:	usleep(10000);
./tools/sensinode/nano_programmer/cdi_program.c:				usleep(1250);
./tools/sensinode/nano_programmer/cdi_program.c:					usleep(300000);
Binary file ./tools/sensinode/nano_programmer/nano_programmer matches
./tools/sensinode/nano_programmer/windows/port.c:			else usleep(500);
./tools/sensinode/nano_programmer/windows/port.c:			else	usleep(500);
./tools/sensinode/nano_programmer/windows/port.c:			else	usleep(1000);
./tools/sensinode/nano_programmer/windows/port.c:			else	usleep(1000);
./tools/sensinode/nano_programmer/windows/port.c:		usleep(1250);
./tools/tunslip6.c:  usleep(10*1000);		/* Wait for hardware 10ms. */
./tools/serial-log.pl:use Time::HiRes qw(usleep);
./tools/tapslip6.c:  usleep(10*1000);		/* Wait for hardware 10ms. */
./tools/wpcapslip/wpcapslip.c:  usleep(10*1000);		/* Wait for hardware 10ms. */
./tools/wpcapslip/wpcap.c:    sleep(1);
Binary file ./tools/tunslip matches
Binary file ./tools/cygwin/cygwin1.dll matches
Binary file ./tools/stm32w/stm32w_flasher/unicodedata.pyd matches
Binary file ./tools/stm32w/stm32w_flasher/w9xpopen.exe matches
Binary file ./tools/stm32w/stm32w_flasher/python26.dll matches
Binary file ./tools/stm32w/stm32w_flasher/JlinkARM.DLL matches
Binary file ./tools/stm32w/stm32w_flasher/bz2.pyd matches
Binary file ./tools/stm32w/stm32w_flasher/_ssl.pyd matches
Binary file ./tools/stm32w/stm32w_flasher/pywintypes26.dll matches
Binary file ./tools/stm32w/stm32w_flasher/FTD2XX.dll matches
Binary file ./tools/stm32w/stm32w_flasher/win32pipe.pyd matches
Binary file ./tools/stm32w/stm32w_flasher/_socket.pyd matches
Binary file ./tools/stm32w/stm32w_flasher/win32api.pyd matches
Binary file ./tools/stm32w/stm32w_flasher/d2xx._d2xx.pyd matches
Binary file ./tools/stm32w/stm32w_flasher/stm32w_flasher.exe matches
Binary file ./tools/stm32w/stm32w_flasher/_ctypes.pyd matches
Binary file ./tools/stm32w/stm32w_flasher/select.pyd matches
Binary file ./tools/stm32w/stm32w_flasher/pyexpat.pyd matches
Binary file ./tools/stm32w/serialdump-linux matches
./tools/stm32w/tapslip6.c:    usleep(10 * 1000);		/* Wait for hardware 10ms. */
Binary file ./tools/stm32w/serialdump-windows.exe matches
./tools/stm32w/serialdump.c:	      usleep(delay);
./tools/stm32w/wpcapslip6/wpcapslip6.c:	usleep(10*1000);		/* Wait for hardware 10ms. */
Binary file ./tools/stm32w/wpcapslip6/wpcapslip6.exe matches
./tools/freebsd-6-setup-slip:sleep 1
./tools/scat.c:  usleep(10*1000);		/* Wait for hardware 10ms. */
./tools/tunslip.c:  usleep(10*1000);		/* Wait for hardware 10ms. */
./platform/msb430/contiki-msb430-main.c:      /* Re-enable interrupts and go to sleep atomically. */
./platform/msb430/contiki-msb430-main.c:      * are asleep, so we discard the processing time done when we
./platform/msb430/dev/rs232.h: *             The return value of the input handler affects the sleep
./platform/msb430/dev/rs232.h: *             is kept sleeping.
./platform/mb851/contiki-main.c:    halSleepWithOptions(SLEEPMODE_IDLE,0);
./platform/mb851/board-mb851.c: * Useful when entering in sleep mode, since all system
./platform/exp5438/contiki-exp5438-main.c:      /* Re-enable interrupts and go to sleep atomically. */
./platform/exp5438/contiki-exp5438-main.c:         are asleep, so we discard the processing time done when we
./platform/exp5438/contiki-exp5438-main.c:      _BIS_SR(GIE | SCG0 | SCG1 | CPUOFF); /* LPM3 sleep. This
./platform/sky/Makefile.common:	$(BSL) -c $(subst _,/,$*) -e && sleep 2 ; \
./platform/sky/Makefile.common:	$(BSL) -c $(subst _,/,$*) $(BSL_FILETYPE) -p $(IHEXFILE) && sleep 2 ; \
./platform/sky/contiki-sky-main.c:      /* before going down to sleep possibly do some management */
./platform/sky/contiki-sky-main.c:      /* Re-enable interrupts and go to sleep atomically. */
./platform/sky/contiki-sky-main.c:	 are asleep, so we discard the processing time done when we
./platform/sky/contiki-sky-main.c:	_BIS_SR(GIE | CPUOFF); /* LPM1 sleep for DMA to work!. */
./platform/sky/contiki-sky-main.c:	_BIS_SR(GIE | SCG0 | SCG1 | CPUOFF); /* LPM3 sleep. This
./platform/cooja/dev/rs232.h: *             The return value of the input handler affects the sleep
./platform/cooja/dev/rs232.h: *             is kept sleeping.
./platform/cooja/lib/simEnvChange.h:// Variable that when set to != 0, stops the mote from falling asleep next tick
./platform/cooja/lib/simEnvChange.h:extern char simDontFallAsleep;
./platform/cooja/lib/simEnvChange.c:char simDontFallAsleep = 0;
./platform/cooja/contiki-cooja-main.c:        if(simDontFallAsleep) {
./platform/cooja/contiki-cooja-main.c:            simDontFallAsleep=0;
./platform/jcreate/dev/acc-sensor.c:    /* Sleep Mode P2.3 */
./platform/jcreate/dev/acc-sensor.c:      /* Sensor deactivated. Changed to sleep mode. */
./platform/avr-ravenlcd/raven3290.c: *      -# The software will disable JTAG in sleep/doze modes. If the JTAG connection fails during
./platform/avr-ravenlcd/raven3290.c: *   -# <b>SEND_SLEEP- (0x83)</b>
./platform/avr-ravenlcd/raven3290.c: *     \section sleep_lcd Sleep and Doze
./platform/avr-ravenlcd/raven3290.c: *   -# Sleeping the 3290p and LCD display drops this to 21 ma with no loss in contiki functionality.
./platform/avr-ravenlcd/raven3290.c: *   -# The RF230 radio draws 15.5/16.5/7.8/1.5/0.02 ma in Rx/Tx/PLL_ON/TRX_OFF/SLEEP states.
./platform/avr-ravenlcd/raven3290.c: *    bulk of power savings; however the 3290p menu can tell it to sleep unconditionally or in a doze cycle.
./platform/avr-ravenlcd/raven3290.c: *   -# Unconditional SLEEP requires pushing the joystick button for wakeup. Once awake the 3290p sends
./platform/avr-ravenlcd/raven3290.c: *   -# As configured, doze sleeps the 3290p for 5 seconds after telling 1284p to sleep for 4 seconds. The 3290p
./platform/avr-ravenlcd/raven3290.c: *    sleep again. Thus the 1284p will be active 20% of the time, although it may ignore the command to sleep
./platform/avr-ravenlcd/raven3290.c: *    depend on actual 1284p wake time and radio usage. Alter the timings as desired, or comment out the 1284p sleep
./platform/avr-ravenlcd/raven3290.c:const char menu_text16[] PROGMEM = "SLEEP";
./platform/avr-ravenlcd/raven3290.c: //   {menu_text16,  0, 16, 11, 17, (uint8_t*)&menu_text16,  menu_run_sleep     },
./platform/avr-ravenlcd/raven3290.c:    {menu_text16,  0, 16, 11, 17, (uint8_t*)1,  menu_run_sleep     },//display "sleep" on wake
./platform/avr-ravenlcd/sleep.h: *      This controls the sleep operation for the LCD.
./platform/avr-ravenlcd/sleep.h:#ifndef __SLEEP_H__
./platform/avr-ravenlcd/sleep.h:#define __SLEEP_H__
./platform/avr-ravenlcd/sleep.h:void sleep_now(int howlong);
./platform/avr-ravenlcd/sleep.h:void sleep_wakeup(void);
./platform/avr-ravenlcd/sleep.h:#endif /* __SLEEP_H__ */
./platform/avr-ravenlcd/menu.c:#include "sleep.h"
./platform/avr-ravenlcd/menu.c:uint8_t sleep_count;
./platform/avr-ravenlcd/menu.c: *   \brief This will start a sleep operation.
./platform/avr-ravenlcd/menu.c:menu_run_sleep(uint8_t *val)
./platform/avr-ravenlcd/menu.c:    /* Tell the 1284P to turn off the radio and sleep */
./platform/avr-ravenlcd/menu.c:	sleep_count=0;
./platform/avr-ravenlcd/menu.c:    uart_serial_send_frame(SEND_SLEEP, 1, (uint8_t *)&sleep_count);
./platform/avr-ravenlcd/menu.c:    /* Go to sleep until button is pushed */
./platform/avr-ravenlcd/menu.c:    sleep_now(0);
./platform/avr-ravenlcd/menu.c:    sleep_wakeup();
./platform/avr-ravenlcd/menu.c: *   \brief This will start a sleep with wakes for temperature measurement and web requests.
./platform/avr-ravenlcd/menu.c:     /* Tell 1284p to sleep for 4 seconds */
./platform/avr-ravenlcd/menu.c:     /* Alter these timings as desired, or comment out to sleep only the 3290p */
./platform/avr-ravenlcd/menu.c:		sleep_count=4;
./platform/avr-ravenlcd/menu.c:        uart_serial_send_frame(SEND_SLEEP, 1, (uint8_t *)&sleep_count);
./platform/avr-ravenlcd/menu.c:     /* Wait for transmission complete, then sleep 3290p for 5 seconds */
./platform/avr-ravenlcd/menu.c:        sleep_now(sleep_count+1);
./platform/avr-ravenlcd/menu.c:    sleep_wakeup();
./platform/avr-ravenlcd/uart.c: *   \brief Turn off UART for sleep mode.
./platform/avr-ravenlcd/uart.c:    /* Clear the TXC bit to allow transmit complete test before sleep*/
./platform/avr-ravenlcd/doc/Doxyfile:                         ../sleep.c \
./platform/avr-ravenlcd/doc/Doxyfile:                         ../sleep.h \
./platform/avr-ravenlcd/Makefile:SRC = adc.c  key.c  lcd.c  raven3290.c  uart.c menu.c sleep.c beep.c temp.c timer.c
./platform/avr-ravenlcd/ravenlcd_3290.aps:<AVRStudio><MANAGEMENT><ProjectName>ravenlcd_3290</ProjectName><Created>25-Apr-2008 11:07:16</Created><LastEdit>28-Aug-2008 17:12:52</LastEdit><ICON>241</ICON><ProjectType>0</ProjectType><Created>25-Apr-2008 11:07:16</Created><Version>4</Version><Build>4, 13, 0, 569</Build><ProjectTypeName>AVR GCC</ProjectTypeName></MANAGEMENT><CODE_CREATION><ObjectFile>default\ravenlcd_3290.elf</ObjectFile><EntryFile></EntryFile><SaveFolder>C:\Atmel\cisco\branches\macipv6\apps\ravenlcd_3290\</SaveFolder></CODE_CREATION><DEBUG_TARGET><CURRENT_TARGET>JTAGICE mkII</CURRENT_TARGET><CURRENT_PART>ATmega3290P</CURRENT_PART><BREAKPOINTS></BREAKPOINTS><IO_EXPAND><HIDE>false</HIDE></IO_EXPAND><REGISTERNAMES><Register>R00</Register><Register>R01</Register><Register>R02</Register><Register>R03</Register><Register>R04</Register><Register>R05</Register><Register>R06</Register><Register>R07</Register><Register>R08</Register><Register>R09</Register><Register>R10</Register><Register>R11</Register><Register>R12</Register><Register>R13</Register><Register>R14</Register><Register>R15</Register><Register>R16</Register><Register>R17</Register><Register>R18</Register><Register>R19</Register><Register>R20</Register><Register>R21</Register><Register>R22</Register><Register>R23</Register><Register>R24</Register><Register>R25</Register><Register>R26</Register><Register>R27</Register><Register>R28</Register><Register>R29</Register><Register>R30</Register><Register>R31</Register></REGISTERNAMES><COM>Auto</COM><COMType>0</COMType><WATCHNUM>0</WATCHNUM><WATCHNAMES><Pane0><Variables>menu</Variables><Variables>result</Variables><Variables>str</Variables><Variables>p</Variables><Variables>n</Variables><Variables>payload</Variables><Variables>numb</Variables></Pane0><Pane1></Pane1><Pane2></Pane2><Pane3></Pane3></WATCHNAMES><BreakOnTrcaeFull>0</BreakOnTrcaeFull></DEBUG_TARGET><Debugger><modules><module></module></modules><Triggers></Triggers></Debugger><AVRGCCPLUGIN><FILES><SOURCEFILE>uart.c</SOURCEFILE><SOURCEFILE>adc.c</SOURCEFILE><SOURCEFILE>key.c</SOURCEFILE><SOURCEFILE>lcd.c</SOURCEFILE><SOURCEFILE>menu.c</SOURCEFILE><SOURCEFILE>raven3290.c</SOURCEFILE><SOURCEFILE>sleep.c</SOURCEFILE><SOURCEFILE>beep.c</SOURCEFILE><SOURCEFILE>timer.c</SOURCEFILE><SOURCEFILE>temp.c</SOURCEFILE><OTHERFILE>default\ravenlcd_3290.lss</OTHERFILE><OTHERFILE>default\ravenlcd_3290.map</OTHERFILE></FILES><CONFIGS><CONFIG><NAME>default</NAME><USESEXTERNALMAKEFILE>NO</USESEXTERNALMAKEFILE><EXTERNALMAKEFILE></EXTERNALMAKEFILE><PART>atmega3290p</PART><HEX>1</HEX><LIST>1</LIST><MAP>1</MAP><OUTPUTFILENAME>ravenlcd_3290.elf</OUTPUTFILENAME><OUTPUTDIR>default\</OUTPUTDIR><ISDIRTY>0</ISDIRTY><OPTIONS><OPTION><FILE>adc.c</FILE><OPTIONLIST></OPTIONLIST></OPTION><OPTION><FILE>beep.c</FILE><OPTIONLIST></OPTIONLIST></OPTION><OPTION><FILE>key.c</FILE><OPTIONLIST></OPTIONLIST></OPTION><OPTION><FILE>lcd.c</FILE><OPTIONLIST></OPTIONLIST></OPTION><OPTION><FILE>menu.c</FILE><OPTIONLIST></OPTIONLIST></OPTION><OPTION><FILE>raven3290.c</FILE><OPTIONLIST></OPTIONLIST></OPTION><OPTION><FILE>sleep.c</FILE><OPTIONLIST></OPTIONLIST></OPTION><OPTION><FILE>uart.c</FILE><OPTIONLIST></OPTIONLIST></OPTION></OPTIONS><INCDIRS><INCLUDE>.\</INCLUDE></INCDIRS><LIBDIRS/><LIBS/><LINKOBJECTS/><OPTIONSFORALL>-Wall -gdwarf-2 -std=gnu99                  -DF_CPU=8000000UL -Os -funsigned-char -funsigned-bitfields -fpack-struct -fshort-enums</OPTIONSFORALL><LINKEROPTIONS></LINKEROPTIONS><SEGMENTS/></CONFIG></CONFIGS><LASTCONFIG>default</LASTCONFIG><USES_WINAVR>1</USES_WINAVR><GCC_LOC>C:\Programme\WinAVR-20080610\bin\avr-gcc.exe</GCC_LOC><MAKE_LOC>C:\Programme\WinAVR-20080610\utils\bin\make.exe</MAKE_LOC></AVRGCCPLUGIN><ProjectFiles><Files><Name>C:\Atmel\cisco\branches\macipv6\apps\ravenlcd_3290\uart.c</Name><Name>C:\Atmel\cisco\branches\macipv6\apps\ravenlcd_3290\adc.c</Name><Name>C:\Atmel\cisco\branches\macipv6\apps\ravenlcd_3290\key.c</Name><Name>C:\Atmel\cisco\branches\macipv6\apps\ravenlcd_3290\lcd.c</Name><Name>C:\Atmel\cisco\branches\macipv6\apps\ravenlcd_3290\menu.c</Name><Name>C:\Atmel\cisco\branches\macipv6\apps\ravenlcd_3290\raven3290.c</Name><Name>C:\Atmel\cisco\branches\macipv6\apps\ravenlcd_3290\sleep.c</Name><Name>C:\Atmel\cisco\branches\macipv6\apps\ravenlcd_3290\beep.c</Name><Name>C:\Atmel\cisco\branches\macipv6\apps\ravenlcd_3290\timer.c</Name><Name>C:\Atmel\cisco\branches\macipv6\apps\ravenlcd_3290\temp.c</Name></Files></ProjectFiles><IOView><usergroups/><sort sorted="0" column="0" ordername="0" orderaddress="0" ordergroup="0"/></IOView><Files><File00000><FileId>00000</FileId><FileName>raven3290.c</FileName><Status>259</Status></File00000><File00001><FileId>00001</FileId><FileName>sleep.c</FileName><Status>257</Status></File00001><File00002><FileId>00002</FileId><FileName>lcd.c</FileName><Status>259</Status></File00002><File00003><FileId>00003</FileId><FileName>timer.c</FileName><Status>259</Status></File00003><File00004><FileId>00004</FileId><FileName>adc.c</FileName><Status>259</Status></File00004><File00005><FileId>00005</FileId><FileName>menu.c</FileName><Status>259</Status></File00005><File00006><FileId>00006</FileId><FileName>temp.c</FileName><Status>259</Status></File00006><File00007><FileId>00007</FileId><FileName>key.c</FileName><Status>259</Status></File00007><File00008><FileId>00008</FileId><FileName>uart.c</FileName><Status>259</Status></File00008></Files><Events><Bookmarks></Bookmarks></Events><Trace><Filters></Filters></Trace></AVRStudio>
./platform/avr-ravenlcd/main.h:#define SEND_SLEEP                    (0x83)
./platform/avr-ravenlcd/sleep.c: *      This controls the sleep operation for the LCD.
./platform/avr-ravenlcd/sleep.c:#include <avr/sleep.h>
./platform/avr-ravenlcd/sleep.c:#include "sleep.h"
./platform/avr-ravenlcd/sleep.c: *   \brief Prepares for and executes sleep. This function sets up the
./platform/avr-ravenlcd/sleep.c: *   processor to enter sleep mode, and to wake up when the joystick
./platform/avr-ravenlcd/sleep.c: *   \param howlong Seconds to sleep, 0=until button pushed
./platform/avr-ravenlcd/sleep.c:sleep_now(int howlong)
./platform/avr-ravenlcd/sleep.c:    /* Setup sleep mode */
./platform/avr-ravenlcd/sleep.c:        set_sleep_mode(SLEEP_MODE_PWR_DOWN);
./platform/avr-ravenlcd/sleep.c:        set_sleep_mode(SLEEP_MODE_PWR_SAVE);
./platform/avr-ravenlcd/sleep.c:    /* Sleep until timeout or button pushed */
./platform/avr-ravenlcd/sleep.c:        sleep_mode();
./platform/avr-ravenlcd/sleep.c: *   The 1284p polls the USART for new data during each sleep cycle.  Upon receiving a
./platform/avr-ravenlcd/sleep.c:sleep_wakeup(void)
./platform/avr-ravenlcd/sleep.c: *   nothing is done. The program will simply continue from the end of the sleep
./platform/avr-ravenlcd/menu.h:void menu_run_sleep(uint8_t *val);
./platform/z1/Makefile.common:	$(BSL) -c $(subst -,/,$*) -e && sleep 2 ; \
./platform/z1/Makefile.common:	$(BSL) -c $(subst -,/,$*) $(BSL_FILETYPE) -p $(IHEXFILE) && sleep 2 ; \
./platform/z1/dev/adxl345.h:#define ADXL345_POWER_CTL_DEFAULT       0x28	  // link bit set, no autosleep, start normal measuring
./platform/z1/dev/adxl345.c:/* This process is sleeping until an interrupt from the accelerometer occurs, which
./platform/z1/contiki-z1-main.c:      /* before going down to sleep possibly do some management */
./platform/z1/contiki-z1-main.c:      /* Re-enable interrupts and go to sleep atomically. */
./platform/z1/contiki-z1-main.c:	 are asleep, so we discard the processing time done when we
./platform/z1/contiki-z1-main.c:      _BIS_SR(GIE | SCG0 | SCG1 | CPUOFF); /* LPM3 sleep. This
./platform/esb/dev/rs232.h: *             The return value of the input handler affects the sleep
./platform/esb/dev/rs232.h: *             is kept sleeping.
./platform/esb/contiki-esb-main.c:      /* before going down to sleep possibly do some management */
./platform/esb/contiki-esb-main.c:      /* Re-enable interrupts and go to sleep atomically. */
./platform/esb/contiki-esb-main.c:	 are asleep, so we discard the processing time done when we
./platform/esb/contiki-esb-main.c:      _BIS_SR(GIE | SCG0 | CPUOFF); /* LPM1 sleep. */
Binary file ./platform/esb/buildscripts/jtag/pyjtag/_parjtag.so matches
./platform/sensinode/dev/m25p16.c: *     deep sleep etc.
./platform/sensinode/dev/m25p16.h: * this sequence should not be used when the sleep interval is estimated to be
./platform/sensinode/dev/m25p16.h: * this sequence should not be used when the sleep interval is estimated to be
./platform/sensinode/dev/m25p16.h: * this sequence should not be used when the sleep interval is estimated to be
./platform/sensinode/contiki-sensinode-main.c:extern volatile __bit sleep_flag;
./platform/sensinode/contiki-sensinode-main.c:      if(sleep_flag) {
./platform/sensinode/contiki-sensinode-main.c:        sleep_flag = 0;
./platform/sensinode/contiki-sensinode-main.c:    SLEEP &= ~OSC_PD;            /* Make sure both HS OSCs are on */
./platform/sensinode/contiki-sensinode-main.c:    while(!(SLEEP & HFRC_STB));  /* Wait for RCOSC to be stable */
./platform/sensinode/contiki-sensinode-main.c:    SLEEP |= OSC_PD;             /* Turn the other one off */
./platform/sensinode/contiki-sensinode-main.c:     * Sleep Timer will wake us up in no more than 7.8ms (max idle interval)
./platform/sensinode/contiki-sensinode-main.c:    SLEEP = (SLEEP & 0xFC) | (LPM_MODE - 1);
./platform/sensinode/contiki-sensinode-main.c:     * Wait 3 NOPs. Either an interrupt occurred and SLEEP.MODE was cleared or
./platform/sensinode/contiki-sensinode-main.c:    if (SLEEP & SLEEP_MODE0) {
./platform/sensinode/contiki-sensinode-main.c:      SLEEP &= ~OSC_PD;            /* Make sure both HS OSCs are on */
./platform/sensinode/contiki-sensinode-main.c:      while(!(SLEEP & XOSC_STB));  /* Wait for XOSC to be stable */
./platform/micaz/dev/cc2420-arch.c:  /* TODO : wakeup from sleep mode */
./platform/stk500/contiki-conf.h:/* How long to wait before terminating an idle TCP connection. Smaller to allow faster sleep. Default is 120 seconds */
./platform/win32/contiki-main.c:    SleepEx(10, TRUE);
./platform/avr-raven/apps/raven-webserver/httpd-cgi.c:  extern unsigned long seconds, sleepseconds;
./platform/avr-raven/apps/raven-webserver/httpd-cgi.c:  static const char httpd_cgi_sensor4[] HTTPD_STRING_ATTR = "<em>Sleeping time :</em> %02d:%02d:%02d (%d%%)<br>";
./platform/avr-raven/apps/raven-webserver/httpd-cgi.c:  if (sleepseconds) {
./platform/avr-raven/apps/raven-webserver/httpd-cgi.c:    p1=100UL*sleepseconds/seconds;
./platform/avr-raven/apps/raven-webserver/httpd-cgi.c:    h=sleepseconds/3600;
./platform/avr-raven/apps/raven-webserver/httpd-cgi.c:    s=sleepseconds-h*3600;
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c:#include <avr/sleep.h>
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c:/* Sleep for howlong seconds, or until UART interrupt if howlong==0.
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c: * Uses TIMER2 with external 32768 Hz crystal to sleep in 1 second multiples.
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c: * The system clock is adjusted to reflect the sleep time.
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c:void micro_sleep(uint8_t howlong)
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c://        set_sleep_mode(SLEEP_MODE_PWR_DOWN);  // UART can't wake from powerdown
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c:        set_sleep_mode(SLEEP_MODE_PWR_SAVE);    // Sleep for howlong seconds
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c:        if (howlong==0) howlong=3;              // 3*32/(32768/1024) = 3 second sleep cycle if not specified
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c://      while(ASSR & (1 << TCN2UB));            // Wait for TCNT2 write to finish before entering sleep.
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c:    SMCR |= (1 <<  SE);                         // Enable sleep mode.
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c://     while(ASSR & (1 << TCN2UB));             // Wait for TCNT2 write to finish before entering sleep.
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c:       sleep_mode();                            // Sleep
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c:       /* Adjust clock.c for the time spent sleeping */
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c://     if (TIMSK2&(1<<OCIE2A)) break;           // Exit sleep if not awakened by TIMER2
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c:       if (saved_howlong) break;                // Exit sleep if nonzero time specified
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c:    SMCR  &= ~(1 << SE);                        //Disable sleep mode after wakeup
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c:            case SEND_SLEEP:
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c:                /* Sleep radio and 1284p. */
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c:                if (cmd.frame[0]==0) {  //Time to sleep in seconds
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c:                /* Unconditional sleep. Don't wake until a serial interrupt. */
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c:                /* Sleep specified number of seconds (3290p "DOZE" mode) */
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c:                /* It sleeps a bit longer so we will be always be awake for the next sleep command. */
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c:                /* Only sleep this cycle if no active TCP/IP connections, for fast browser responsed */
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c:                PRINTF ("\nsleep %d radio state %d...",cmd.frame[0],radio_state);
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c:                /*Sleep for specified time*/
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c:                PRINTF("\nSleeping...");
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c:                micro_sleep(cmd.frame[0]);
./platform/avr-raven/apps/raven-lcd-interface/raven-lcd.c:    /* Tell sleep routine if a  reception occurred */
./platform/avr-raven/contiki-conf.h:/* The sleep timer in raven-lcd.c also uses the crystal and adds a TIMER2 interrupt routine if not already define by clock.c */
./platform/avr-raven/contiki-conf.h:/* Calibration is automatic when the radio wakes so is not necessary when the radio periodically sleeps */
./platform/avr-raven/contiki-conf.h:/* Allow MCU sleeping between channel checks */
./platform/avr-raven/contiki-conf.h:#define RDC_CONF_MCU_SLEEP         0
./platform/avr-raven/contiki-conf.h:/* How long to wait before terminating an idle TCP connection. Smaller to allow faster sleep. Default is 120 seconds */
./platform/avr-raven/raven-lcd.h:#define SEND_SLEEP             (0x83)
./platform/cc2530dk/contiki-main.c:extern volatile __bit sleep_flag;
./platform/cc2530dk/contiki-main.c:      if(sleep_flag) {
./platform/cc2530dk/contiki-main.c:        sleep_flag = 0;
./platform/cc2530dk/contiki-main.c:    SLEEP &= ~OSC_PD;            /* Make sure both HS OSCs are on */
./platform/cc2530dk/contiki-main.c:    while(!(SLEEP & HFRC_STB));  /* Wait for RCOSC to be stable */
./platform/cc2530dk/contiki-main.c:    SLEEP |= OSC_PD;             /* Turn the other one off */
./platform/cc2530dk/contiki-main.c:     * Sleep Timer will wake us up in no more than 7.8ms (max idle interval)
./platform/cc2530dk/contiki-main.c:    SLEEPCMD = (SLEEPCMD & 0xFC) | (LPM_MODE - 1);
./platform/cc2530dk/contiki-main.c:     * Wait 3 NOPs. Either an interrupt occurred and SLEEP.MODE was cleared or
./platform/cc2530dk/contiki-main.c:    if(SLEEPCMD & SLEEP_MODE0) {
./platform/cc2530dk/contiki-main.c:      SLEEPCMD &= ~SLEEP_OSC_PD;            /* Make sure both HS OSCs are on */
./platform/cc2530dk/contiki-main.c:      while(!(SLEEPCMD & SLEEP_XOSC_STB));  /* Wait for XOSC to be stable */
./platform/wismote/contiki-wismote-main.c:      /* Re-enable interrupts and go to sleep atomically. */
./platform/wismote/contiki-wismote-main.c:	 are asleep, so we discard the processing time done when we
./platform/wismote/contiki-wismote-main.c:      _BIS_SR(GIE | SCG0 | SCG1 | CPUOFF); /* LPM3 sleep. This
./platform/avr-ravenusb/contiki-conf.h:/* Calibration is automatic when the radio wakes so is not necessary when the radio periodically sleeps */
./platform/mbxxx/contiki-main.c:    halSleepWithOptions(SLEEPMODE_IDLE,0);
./platform/mbxxx/board-mbxxx.c: * Useful when entering in sleep mode, since all system
./platform/mbxxx/clock.c:void sleep_seconds(int seconds)
./platform/mbxxx/clock.c:  halSleepForQsWithOptions(&quarter_seconds, 0);
./platform/avr-atmega128rfa1/apps/raven-webserver/httpd-cgi.c:  extern unsigned long seconds, sleepseconds;
./platform/avr-atmega128rfa1/apps/raven-webserver/httpd-cgi.c:  static const char httpd_cgi_sensor4[] HTTPD_STRING_ATTR = "<em>Sleeping time :</em> %02d:%02d:%02d (%d%%)<br>";
./platform/avr-atmega128rfa1/apps/raven-webserver/httpd-cgi.c:  if (sleepseconds) {
./platform/avr-atmega128rfa1/apps/raven-webserver/httpd-cgi.c:    p1=100UL*sleepseconds/seconds;
./platform/avr-atmega128rfa1/apps/raven-webserver/httpd-cgi.c:    h=sleepseconds/3600;
./platform/avr-atmega128rfa1/apps/raven-webserver/httpd-cgi.c:    s=sleepseconds-h*3600;
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c:#include <avr/sleep.h>
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c:/* Sleep for howlong seconds, or until UART interrupt if howlong==0.
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c: * Uses TIMER2 with external 32768 Hz crystal to sleep in 1 second multiples.
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c: * The system clock is adjusted to reflect the sleep time.
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c:void micro_sleep(uint8_t howlong)
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c://        set_sleep_mode(SLEEP_MODE_PWR_DOWN);  // UART can't wake from powerdown
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c:        set_sleep_mode(SLEEP_MODE_PWR_SAVE);    // Sleep for howlong seconds
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c:        if (howlong==0) howlong=3;              // 3*32/(32768/1024) = 3 second sleep cycle if not specified
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c://      while(ASSR & (1 << TCN2UB));            // Wait for TCNT2 write to finish before entering sleep.
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c:    SMCR |= (1 <<  SE);                         // Enable sleep mode.
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c://     while(ASSR & (1 << TCN2UB));             // Wait for TCNT2 write to finish before entering sleep.
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c:       sleep_mode();                            // Sleep
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c:       /* Adjust clock.c for the time spent sleeping */
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c://     if (TIMSK2&(1<<OCIE2A)) break;           // Exit sleep if not awakened by TIMER2
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c:       if (saved_howlong) break;                // Exit sleep if nonzero time specified
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c:    SMCR  &= ~(1 << SE);                        //Disable sleep mode after wakeup
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c:            case SEND_SLEEP:
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c:                /* Sleep radio and 1284p. */
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c:                if (cmd.frame[0]==0) {  //Time to sleep in seconds
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c:                /* Unconditional sleep. Don't wake until a serial interrupt. */
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c:                /* Sleep specified number of seconds (3290p "DOZE" mode) */
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c:                /* It sleeps a bit longer so we will be always be awake for the next sleep command. */
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c:                /* Only sleep this cycle if no active TCP/IP connections */
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c:                PRINTF ("\nsleep %d radio state %d...",cmd.frame[0],radio_state);
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c:                /*Sleep for specified time*/
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c:                PRINTF("\nSleeping...");
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c:                micro_sleep(cmd.frame[0]);
./platform/avr-atmega128rfa1/apps/raven-lcd-interface/raven-lcd.c:    /* Tell sleep routine if a  reception occurred */
./platform/avr-atmega128rfa1/contiki-conf.h:/* The sleep timer requires the crystal and adds a TIMER2 interrupt routine if not already define by clock.c */
./platform/avr-atmega128rfa1/contiki-conf.h:/* Allow MCU sleeping between channel checks */
./platform/avr-atmega128rfa1/contiki-conf.h:#define RDC_CONF_MCU_SLEEP         1
./platform/avr-atmega128rfa1/contiki-conf.h:/* How long to wait before terminating an idle TCP connection. Smaller to allow faster sleep. Default is 120 seconds */
./platform/avr-atmega128rfa1/raven-lcd.h:#define SEND_SLEEP             (0x83)
./examples/mb851/udp-ipv6-sleep/README:UDP packets to a fixed server. The client will also go in a deep sleep state
./examples/mb851/udp-ipv6-sleep/udp-client.c:#include "sleep.h"
./examples/mb851/udp-ipv6-sleep/udp-client.c:/* Seconds during which the system must be in deep sleep.
./examples/mb851/udp-ipv6-sleep/udp-client.c: * During deep sleep all the OS is frozen. */
./examples/mb851/udp-ipv6-sleep/udp-client.c:#define SLEEP_INTERVAL_SECONDS		6
./examples/mb851/udp-ipv6-sleep/udp-client.c:/* System does not go to sleep until AWAKE_INTERVAL is passed.
./examples/mb851/udp-ipv6-sleep/udp-client.c:    if(etimer_expired(&wake_timer)){  // if timer hasn't expired do not go in deep sleep, in order to receive a response.
./examples/mb851/udp-ipv6-sleep/udp-client.c:		printf("Sleeping...\r\n");
./examples/mb851/udp-ipv6-sleep/udp-client.c:		sleep_seconds(SLEEP_INTERVAL_SECONDS); // Put system in deep sleep mode for a while.
./examples/mb851/udp-ipv6-sleep/udp-client.c:     * so that it can force the system to go into deep sleep. */
./examples/mb851/shell-exec/Makefile:	(echo; sleep 4; echo "~K"; sleep 4; \
./examples/mb851/shell-exec/Makefile:         echo "dec64 | write $*.ce | null"; sleep 4; \
./examples/mb851/shell-exec/Makefile:	 ../../../tools/base64-encode < $<; sleep 4; \
./examples/mb851/shell-exec/Makefile:         echo ""; echo "~K"; echo "read $*.ce | size"; sleep 4) | make login
./examples/jcreate/Makefile:	(echo; sleep 4; echo "~K"; sleep 4; \
./examples/jcreate/Makefile:         echo "repeat 0 0 { acc | leds 1 } &"; sleep 4) | make login
./examples/jcreate/Makefile:	(echo; sleep 4; echo "~K"; sleep 4; \
./examples/jcreate/Makefile:         echo "dec64 | write $*.ce | null"; sleep 4; \
./examples/jcreate/Makefile:	 ../../tools/base64-encode < $<; sleep 4; \
./examples/jcreate/Makefile:         echo "~K"; sleep 4; \
./examples/jcreate/Makefile:         echo "read $*.ce | size"; sleep 4) | make login
./examples/jcreate/Makefile:	(echo; sleep 4; echo "~K"; sleep 4; \
./examples/jcreate/Makefile:         echo "netcmd { recvnetfile | write $*.ce | size | send } "; sleep 4; \
./examples/jcreate/Makefile:         echo "netfile $*.ce"; sleep 4;\
./examples/jcreate/Makefile:         echo "collect | binprint"; sleep 40) | make login
./examples/ipv6/native-border-router/slip-dev.c:  usleep(10*1000);		/* Wait for hardware 10ms. */
./examples/webserver-ipv6-raven/README:and sleep and radio statistics, on web pages.
./examples/sky-shell-exec/Makefile:	(echo; sleep 4; echo "~K"; sleep 4; \
./examples/sky-shell-exec/Makefile:         echo "dec64 | write $*.ce | null"; sleep 4; \
./examples/sky-shell-exec/Makefile:	 ../../tools/base64-encode < $<; sleep 4; \
./examples/sky-shell-exec/Makefile:         echo ""; echo "~K"; echo "read $*.ce | size"; sleep 4) | make login
Binary file ./examples/hello-world/hello-world.cooja matches
./core/net/rime/rime.c:   * (duty cycle, sleep time, or something similar). But this is OK
./core/net/mac/lpp.c:         so, we refrain from sending our broadcast until one sleep
./core/net/mac/cxmac.c:	   asleep. */
./core/net/mac/contikimac.c:/* More aggressive radio sleeping when channel is busy with other traffic */
./core/net/mac/contikimac.c:#ifndef WITH_FAST_SLEEP
./core/net/mac/contikimac.c:#define WITH_FAST_SLEEP              1
./core/net/mac/contikimac.c:/* MCU can sleep during radio off */
./core/net/mac/contikimac.c:#ifndef RDC_CONF_MCU_SLEEP
./core/net/mac/contikimac.c:#define RDC_CONF_MCU_SLEEP           0
./core/net/mac/contikimac.c:/* CCA_SLEEP_TIME is the time between two successive CCA checks. */
./core/net/mac/contikimac.c:#define CCA_SLEEP_TIME                     RTIMER_ARCH_SECOND / 2000
./core/net/mac/contikimac.c:#define CCA_SLEEP_TIME                     (RTIMER_ARCH_SECOND / 2000) + 1
./core/net/mac/contikimac.c:#define CHECK_TIME                         (CCA_COUNT_MAX * (CCA_CHECK_TIME + CCA_SLEEP_TIME))
./core/net/mac/contikimac.c:#define CHECK_TIME_TX                      (CCA_COUNT_MAX_TX * (CCA_CHECK_TIME + CCA_SLEEP_TIME))
./core/net/mac/contikimac.c:   CCA_CHECK_TIME + CCA_SLEEP_TIME) that we allow to be silent before
./core/net/mac/contikimac.c:   WITH_FAST_SLEEP is enabled. */
./core/net/mac/contikimac.c:      schedule_powercycle_fixed(t, RTIMER_NOW() + CCA_SLEEP_TIME);
./core/net/mac/contikimac.c:        if(WITH_FAST_SLEEP &&
./core/net/mac/contikimac.c:        schedule_powercycle(t, CCA_CHECK_TIME + CCA_SLEEP_TIME);
./core/net/mac/contikimac.c:	     /* Schedule the next powercycle interrupt, or sleep the mcu until then.
./core/net/mac/contikimac.c:                Sleeping will not exit from this interrupt, so ensure an occasional wake cycle
./core/net/mac/contikimac.c:#if RDC_CONF_MCU_SLEEP
./core/net/mac/contikimac.c:      static uint8_t sleepcycle;
./core/net/mac/contikimac.c:      if ((sleepcycle++<16) && !we_are_sending && !radio_is_on) {
./core/net/mac/contikimac.c:        rtimer_arch_sleep(CYCLE_TIME - (RTIMER_NOW() - cycle_start));
./core/net/mac/contikimac.c:        sleepcycle = 0;
./core/net/mac/contikimac.c:      while(RTIMER_CLOCK_LT(RTIMER_NOW(), t0 + CCA_SLEEP_TIME)) { }
./core/net/mac/xmac.c:	   asleep. */
./core/sys/clock.h: * or sleep will often use one for wake and disable the other, then give
./core/sys/process.h: * may choose to put the CPU to sleep when there are no pending
